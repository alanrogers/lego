<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>lego: popnode.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">lego
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Lego is a system of programs written in C and Python, which uses counts of nucleotide site patterns to infer thehistoryofpopulationsize,subdivision,andgeneflow.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">popnode.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A single segment of a population tree.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;popnode.h&quot;</code><br />
<code>#include &quot;gene.h&quot;</code><br />
<code>#include &quot;misc.h&quot;</code><br />
<code>#include &quot;parstore.h&quot;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;float.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;gsl/gsl_randist.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_node_store.html">NodeStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure allows you to allocate <a class="el" href="struct_pop_node.html">PopNode</a> objects in an array and then dole them out one at a time via calls to NodeStore_alloc.  <a href="struct_node_store.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab04a12a01209a7133ca0dd64275bc7f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab04a12a01209a7133ca0dd64275bc7f1"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#ab04a12a01209a7133ca0dd64275bc7f1">PopNode_sanityCheck</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *self, const char *file, int lineno)</td></tr>
<tr class="memdesc:ab04a12a01209a7133ca0dd64275bc7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check sanity of <a class="el" href="struct_pop_node.html">PopNode</a>. <br /></td></tr>
<tr class="separator:ab04a12a01209a7133ca0dd64275bc7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba39acf5a9ab18b0e43397fcc4a963f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#abba39acf5a9ab18b0e43397fcc4a963f">PopNode_randomize_r</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *self, <a class="el" href="struct_bounds.html">Bounds</a> bnd, gsl_rng *rng)</td></tr>
<tr class="memdesc:abba39acf5a9ab18b0e43397fcc4a963f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recurse through the tree perturbing free parameters.  <a href="#abba39acf5a9ab18b0e43397fcc4a963f">More...</a><br /></td></tr>
<tr class="separator:abba39acf5a9ab18b0e43397fcc4a963f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632b830ab1cc9d151f9dbc0ea548b7b8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#a632b830ab1cc9d151f9dbc0ea548b7b8">PopNode_gaussian_r</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *self, <a class="el" href="struct_bounds.html">Bounds</a> bnd, <a class="el" href="struct_par_store.html">ParStore</a> *ps, gsl_rng *rng)</td></tr>
<tr class="memdesc:a632b830ab1cc9d151f9dbc0ea548b7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the population tree to reset the value of each Gaussian parameter by sampling from the relevant distribution.  <a href="#a632b830ab1cc9d151f9dbc0ea548b7b8">More...</a><br /></td></tr>
<tr class="separator:a632b830ab1cc9d151f9dbc0ea548b7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495a0cd6824be7dc5ed5481be8c77e16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a495a0cd6824be7dc5ed5481be8c77e16"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#a495a0cd6824be7dc5ed5481be8c77e16">PopNode_sanityFromLeaf</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *self, const char *file, int line)</td></tr>
<tr class="memdesc:a495a0cd6824be7dc5ed5481be8c77e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for errors in <a class="el" href="struct_pop_node.html">PopNode</a> tree. Call this from each leaf node. <br /></td></tr>
<tr class="separator:a495a0cd6824be7dc5ed5481be8c77e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2061bdfef1c0903521cd3ed58c029f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2061bdfef1c0903521cd3ed58c029f9"></a>
<a class="el" href="struct_pop_node.html">PopNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#ac2061bdfef1c0903521cd3ed58c029f9">PopNode_root</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *self)</td></tr>
<tr class="memdesc:ac2061bdfef1c0903521cd3ed58c029f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find root of population tree, starting from given node. <br /></td></tr>
<tr class="separator:ac2061bdfef1c0903521cd3ed58c029f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c995115fea8e4eaaf2d9b2af3e6e1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8c995115fea8e4eaaf2d9b2af3e6e1f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#ad8c995115fea8e4eaaf2d9b2af3e6e1f">PopNode_clear</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *self)</td></tr>
<tr class="memdesc:ad8c995115fea8e4eaaf2d9b2af3e6e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all references to samples from tree of populations. <br /></td></tr>
<tr class="separator:ad8c995115fea8e4eaaf2d9b2af3e6e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cc1d72eeefaa448f5624e91b6ccaef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#a39cc1d72eeefaa448f5624e91b6ccaef">PopNode_untouch</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *self)</td></tr>
<tr class="memdesc:a39cc1d72eeefaa448f5624e91b6ccaef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all "touched" values to "false".  <a href="#a39cc1d72eeefaa448f5624e91b6ccaef">More...</a><br /></td></tr>
<tr class="separator:a39cc1d72eeefaa448f5624e91b6ccaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf42247afc92469a3a8c1b8cf0cdbb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaf42247afc92469a3a8c1b8cf0cdbb2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#acaf42247afc92469a3a8c1b8cf0cdbb2">PopNode_isClear</a> (const <a class="el" href="struct_pop_node.html">PopNode</a> *self)</td></tr>
<tr class="memdesc:acaf42247afc92469a3a8c1b8cf0cdbb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if <a class="el" href="struct_pop_node.html">PopNode</a> tree is empty of samples. <br /></td></tr>
<tr class="separator:acaf42247afc92469a3a8c1b8cf0cdbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3809b4a3767fc93af5fb1eb06dce78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf3809b4a3767fc93af5fb1eb06dce78"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#abf3809b4a3767fc93af5fb1eb06dce78">PopNode_print</a> (FILE *fp, <a class="el" href="struct_pop_node.html">PopNode</a> *self, int indent)</td></tr>
<tr class="memdesc:abf3809b4a3767fc93af5fb1eb06dce78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a <a class="el" href="struct_pop_node.html">PopNode</a> and (recursively) its descendants. <br /></td></tr>
<tr class="separator:abf3809b4a3767fc93af5fb1eb06dce78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9683e39b487642b3b37eafa0513c61c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9683e39b487642b3b37eafa0513c61c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#af9683e39b487642b3b37eafa0513c61c">PopNode_printShallow</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *self, FILE *fp)</td></tr>
<tr class="memdesc:af9683e39b487642b3b37eafa0513c61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a <a class="el" href="struct_pop_node.html">PopNode</a> but not its descendants. <br /></td></tr>
<tr class="separator:af9683e39b487642b3b37eafa0513c61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74590003fe296cb82da9010d66520fa9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74590003fe296cb82da9010d66520fa9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#a74590003fe296cb82da9010d66520fa9">PopNode_nsamples</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *self)</td></tr>
<tr class="memdesc:a74590003fe296cb82da9010d66520fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of samples in a <a class="el" href="struct_pop_node.html">PopNode</a>. <br /></td></tr>
<tr class="separator:a74590003fe296cb82da9010d66520fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243771d5d518c1a0fcc0487e5f06df51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a243771d5d518c1a0fcc0487e5f06df51"></a>
<a class="el" href="struct_pop_node.html">PopNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#a243771d5d518c1a0fcc0487e5f06df51">PopNode_new</a> (double *twoN, bool twoNfree, double *start, bool startFree, <a class="el" href="struct_node_store.html">NodeStore</a> *ns)</td></tr>
<tr class="memdesc:a243771d5d518c1a0fcc0487e5f06df51"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_pop_node.html">PopNode</a> constructor. <br /></td></tr>
<tr class="separator:a243771d5d518c1a0fcc0487e5f06df51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af039f9acdd8aee304d861eb7488e08ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af039f9acdd8aee304d861eb7488e08ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#af039f9acdd8aee304d861eb7488e08ab">PopNode_addChild</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *parent, <a class="el" href="struct_pop_node.html">PopNode</a> *child)</td></tr>
<tr class="memdesc:af039f9acdd8aee304d861eb7488e08ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect parent and child. <br /></td></tr>
<tr class="separator:af039f9acdd8aee304d861eb7488e08ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa969e7747efda5dbeb88a33d648b54c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa969e7747efda5dbeb88a33d648b54c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#aa969e7747efda5dbeb88a33d648b54c1">PopNode_addSample</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *self, <a class="el" href="struct_gene.html">Gene</a> *gene)</td></tr>
<tr class="memdesc:aa969e7747efda5dbeb88a33d648b54c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a sample to a <a class="el" href="struct_pop_node.html">PopNode</a>. <br /></td></tr>
<tr class="separator:aa969e7747efda5dbeb88a33d648b54c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bd97ddbb6bbf3f7dd6fe095c05e783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#ae6bd97ddbb6bbf3f7dd6fe095c05e783">PopNode_mix</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *child, double *mPtr, bool mixFree, <a class="el" href="struct_pop_node.html">PopNode</a> *introgressor, <a class="el" href="struct_pop_node.html">PopNode</a> *native)</td></tr>
<tr class="memdesc:ae6bd97ddbb6bbf3f7dd6fe095c05e783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect a child <a class="el" href="struct_pop_node.html">PopNode</a> to two parents.  <a href="#ae6bd97ddbb6bbf3f7dd6fe095c05e783">More...</a><br /></td></tr>
<tr class="separator:ae6bd97ddbb6bbf3f7dd6fe095c05e783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6a75adb1a581695e227e790d9da6ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a6a75adb1a581695e227e790d9da6ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#a0a6a75adb1a581695e227e790d9da6ae">PopNode_newGene</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *self, unsigned ndx)</td></tr>
<tr class="memdesc:a0a6a75adb1a581695e227e790d9da6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_pop_node.html">PopNode</a> constructor. <br /></td></tr>
<tr class="separator:a0a6a75adb1a581695e227e790d9da6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097d416b733c640e4cbfcd7caf446bf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a097d416b733c640e4cbfcd7caf446bf3"></a>
<a class="el" href="struct_gene.html">Gene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#a097d416b733c640e4cbfcd7caf446bf3">PopNode_coalesce</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *self, gsl_rng *rng)</td></tr>
<tr class="memdesc:a097d416b733c640e4cbfcd7caf446bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coalesce gene tree within population tree. <br /></td></tr>
<tr class="separator:a097d416b733c640e4cbfcd7caf446bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0bcef4e03d9641ff390bc4774d6d03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc0bcef4e03d9641ff390bc4774d6d03"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#abc0bcef4e03d9641ff390bc4774d6d03">PopNode_free</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *self)</td></tr>
<tr class="memdesc:abc0bcef4e03d9641ff390bc4774d6d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free node but not descendants. <br /></td></tr>
<tr class="separator:abc0bcef4e03d9641ff390bc4774d6d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e0578531c5bec8f70842afca455eeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#a83e0578531c5bec8f70842afca455eeb">PopNode_randomize</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *self, <a class="el" href="struct_bounds.html">Bounds</a> bnd, gsl_rng *rng)</td></tr>
<tr class="memdesc:a83e0578531c5bec8f70842afca455eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly perturb all free parameters in tree while maintaining inequality constraints.  <a href="#a83e0578531c5bec8f70842afca455eeb">More...</a><br /></td></tr>
<tr class="separator:a83e0578531c5bec8f70842afca455eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cebd64c243809bffc0cd835752d96f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#aa1cebd64c243809bffc0cd835752d96f">PopNode_gaussian</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *self, <a class="el" href="struct_bounds.html">Bounds</a> bnd, <a class="el" href="struct_par_store.html">ParStore</a> *ps, gsl_rng *rng)</td></tr>
<tr class="memdesc:aa1cebd64c243809bffc0cd835752d96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the value of each Gaussian parameter by sampling from the relevant distribution.  <a href="#aa1cebd64c243809bffc0cd835752d96f">More...</a><br /></td></tr>
<tr class="separator:aa1cebd64c243809bffc0cd835752d96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e2cc4e1286560fecccd37fac51a884"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48e2cc4e1286560fecccd37fac51a884"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#a48e2cc4e1286560fecccd37fac51a884">PopNode_feasible</a> (const <a class="el" href="struct_pop_node.html">PopNode</a> *self, <a class="el" href="struct_bounds.html">Bounds</a> bnd)</td></tr>
<tr class="memdesc:a48e2cc4e1286560fecccd37fac51a884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if parameters satisfy inequality constraints, or 0 otherwise. <br /></td></tr>
<tr class="separator:a48e2cc4e1286560fecccd37fac51a884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787a8e3df9a737056d227de9535647fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#a787a8e3df9a737056d227de9535647fa">PopNode_shiftParamPtrs</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *self, size_t dp, int sign)</td></tr>
<tr class="memdesc:a787a8e3df9a737056d227de9535647fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add dp to each parameter pointer, using ordinary (not pointer) arithmetic.  <a href="#a787a8e3df9a737056d227de9535647fa">More...</a><br /></td></tr>
<tr class="separator:a787a8e3df9a737056d227de9535647fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bb7c23ac6fd4fa34283ac6918a4b21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#a52bb7c23ac6fd4fa34283ac6918a4b21">PopNode_shiftPopNodePtrs</a> (<a class="el" href="struct_pop_node.html">PopNode</a> *self, size_t dp, int sign)</td></tr>
<tr class="memdesc:a52bb7c23ac6fd4fa34283ac6918a4b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add dp to each <a class="el" href="struct_pop_node.html">PopNode</a> pointer, using ordinary (not pointer) arithmetic.  <a href="#a52bb7c23ac6fd4fa34283ac6918a4b21">More...</a><br /></td></tr>
<tr class="separator:a52bb7c23ac6fd4fa34283ac6918a4b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8955e500da0a712d161d84c3486727b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_node_store.html">NodeStore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#a8955e500da0a712d161d84c3486727b0">NodeStore_new</a> (int len, <a class="el" href="struct_pop_node.html">PopNode</a> *v)</td></tr>
<tr class="memdesc:a8955e500da0a712d161d84c3486727b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new <a class="el" href="struct_node_store.html" title="This structure allows you to allocate PopNode objects in an array and then dole them out one at a tim...">NodeStore</a>, which provides an interface for getting <a class="el" href="struct_pop_node.html">PopNode</a> objects, one at a time, out of a previously-allocated array v.  <a href="#a8955e500da0a712d161d84c3486727b0">More...</a><br /></td></tr>
<tr class="separator:a8955e500da0a712d161d84c3486727b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151f25e883d267b05e57811a7aee3e00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a151f25e883d267b05e57811a7aee3e00"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#a151f25e883d267b05e57811a7aee3e00">NodeStore_free</a> (<a class="el" href="struct_node_store.html">NodeStore</a> *self)</td></tr>
<tr class="memdesc:a151f25e883d267b05e57811a7aee3e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for <a class="el" href="struct_node_store.html" title="This structure allows you to allocate PopNode objects in an array and then dole them out one at a tim...">NodeStore</a>. <br /></td></tr>
<tr class="separator:a151f25e883d267b05e57811a7aee3e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f44cc2e60e06964d0fa7f43545b7ade"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pop_node.html">PopNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#a2f44cc2e60e06964d0fa7f43545b7ade">NodeStore_alloc</a> (<a class="el" href="struct_node_store.html">NodeStore</a> *self)</td></tr>
<tr class="memdesc:a2f44cc2e60e06964d0fa7f43545b7ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to an unused <a class="el" href="struct_pop_node.html">PopNode</a> object within <a class="el" href="struct_node_store.html" title="This structure allows you to allocate PopNode objects in an array and then dole them out one at a tim...">NodeStore</a>.  <a href="#a2f44cc2e60e06964d0fa7f43545b7ade">More...</a><br /></td></tr>
<tr class="separator:a2f44cc2e60e06964d0fa7f43545b7ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092848a150eb15bac76bb65a0cbc30e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a092848a150eb15bac76bb65a0cbc30e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#a092848a150eb15bac76bb65a0cbc30e2">SampNdx_init</a> (<a class="el" href="struct_samp_ndx.html">SampNdx</a> *self)</td></tr>
<tr class="memdesc:a092848a150eb15bac76bb65a0cbc30e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set everything to zero. <br /></td></tr>
<tr class="separator:a092848a150eb15bac76bb65a0cbc30e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae747836810afb30f2a615c9a4c692b77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#ae747836810afb30f2a615c9a4c692b77">SampNdx_addSamples</a> (<a class="el" href="struct_samp_ndx.html">SampNdx</a> *self, unsigned nsamples, <a class="el" href="struct_pop_node.html">PopNode</a> *pnode)</td></tr>
<tr class="memdesc:ae747836810afb30f2a615c9a4c692b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add samples for a single population.  <a href="#ae747836810afb30f2a615c9a4c692b77">More...</a><br /></td></tr>
<tr class="separator:ae747836810afb30f2a615c9a4c692b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc307f239dcf3390dca6b966c0d9b84e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#adc307f239dcf3390dca6b966c0d9b84e">SampNdx_populateTree</a> (<a class="el" href="struct_samp_ndx.html">SampNdx</a> *self)</td></tr>
<tr class="memdesc:adc307f239dcf3390dca6b966c0d9b84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put samples into the gene tree.  <a href="#adc307f239dcf3390dca6b966c0d9b84e">More...</a><br /></td></tr>
<tr class="separator:adc307f239dcf3390dca6b966c0d9b84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9939c38e54215785d0ee601aeb6c23bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9939c38e54215785d0ee601aeb6c23bf"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>SampNdx_size</b> (<a class="el" href="struct_samp_ndx.html">SampNdx</a> *self)</td></tr>
<tr class="separator:a9939c38e54215785d0ee601aeb6c23bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef67024f7444caedcd299ffec5037932"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#aef67024f7444caedcd299ffec5037932">SampNdx_equals</a> (const <a class="el" href="struct_samp_ndx.html">SampNdx</a> *lhs, const <a class="el" href="struct_samp_ndx.html">SampNdx</a> *rhs)</td></tr>
<tr class="memdesc:aef67024f7444caedcd299ffec5037932"><td class="mdescLeft">&#160;</td><td class="mdescRight">This equality check doesn't do much, because the pointers in different <a class="el" href="struct_samp_ndx.html">SampNdx</a> objects don't have to be (in fact shouldn't be) equal.  <a href="#aef67024f7444caedcd299ffec5037932">More...</a><br /></td></tr>
<tr class="separator:aef67024f7444caedcd299ffec5037932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0a85b6108243f1def413bf93d56521"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b0a85b6108243f1def413bf93d56521"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#a7b0a85b6108243f1def413bf93d56521">SampNdx_sanityCheck</a> (<a class="el" href="struct_samp_ndx.html">SampNdx</a> *self, const char *file, int line)</td></tr>
<tr class="memdesc:a7b0a85b6108243f1def413bf93d56521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check sanity of a <a class="el" href="struct_samp_ndx.html">SampNdx</a>. <br /></td></tr>
<tr class="separator:a7b0a85b6108243f1def413bf93d56521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e660609a395a135a64ef7ba2c48f05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#a17e660609a395a135a64ef7ba2c48f05">SampNdx_ptrsLegal</a> (<a class="el" href="struct_samp_ndx.html">SampNdx</a> *self, <a class="el" href="struct_pop_node.html">PopNode</a> *start, <a class="el" href="struct_pop_node.html">PopNode</a> *end)</td></tr>
<tr class="memdesc:a17e660609a395a135a64ef7ba2c48f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if all pointers in <a class="el" href="struct_samp_ndx.html">SampNdx</a> are in [start,end); return 0 otherwise.  <a href="#a17e660609a395a135a64ef7ba2c48f05">More...</a><br /></td></tr>
<tr class="separator:a17e660609a395a135a64ef7ba2c48f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4984b4dddc29e3125dbcb5614e41e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="popnode_8c.html#adf4984b4dddc29e3125dbcb5614e41e1">SampNdx_shiftPtrs</a> (<a class="el" href="struct_samp_ndx.html">SampNdx</a> *self, size_t dpop, int sign)</td></tr>
<tr class="memdesc:adf4984b4dddc29e3125dbcb5614e41e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift all pointers within <a class="el" href="struct_samp_ndx.html">SampNdx</a> by an offset of magnitude dpop.  <a href="#adf4984b4dddc29e3125dbcb5614e41e1">More...</a><br /></td></tr>
<tr class="separator:adf4984b4dddc29e3125dbcb5614e41e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A single segment of a population tree. </p>
<dl class="section author"><dt>Author</dt><dd>Alan R. Rogers <a class="el" href="struct_pop_node.html">PopNode</a> objects can be linked together into a network, which models bifurcation of populations and gene flow among them. Each <a class="el" href="struct_pop_node.html">PopNode</a> knows its size and duration. It has pointers to parents and children. If it has two parents, there is also a mixing parameter, which determines what fraction of the node derives from each parent. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a2f44cc2e60e06964d0fa7f43545b7ade"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pop_node.html">PopNode</a>* NodeStore_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node_store.html">NodeStore</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to an unused <a class="el" href="struct_pop_node.html">PopNode</a> object within <a class="el" href="struct_node_store.html" title="This structure allows you to allocate PopNode objects in an array and then dole them out one at a tim...">NodeStore</a>. </p>
<p>Abort if none are left. </p>

<p>References <a class="el" href="misc_8c.html#a1f2415ec1f22a3a73f7702c0143d9402">eprintf()</a>.</p>

<p>Referenced by <a class="el" href="popnode_8c.html#a243771d5d518c1a0fcc0487e5f06df51">PopNode_new()</a>, and <a class="el" href="popnode_8c.html#adf4984b4dddc29e3125dbcb5614e41e1">SampNdx_shiftPtrs()</a>.</p>

</div>
</div>
<a class="anchor" id="a8955e500da0a712d161d84c3486727b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node_store.html">NodeStore</a>* NodeStore_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pop_node.html">PopNode</a> *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new <a class="el" href="struct_node_store.html" title="This structure allows you to allocate PopNode objects in an array and then dole them out one at a tim...">NodeStore</a>, which provides an interface for getting <a class="el" href="struct_pop_node.html">PopNode</a> objects, one at a time, out of a previously-allocated array v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of <a class="el" href="struct_pop_node.html">PopNode</a> objects in array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>array of <a class="el" href="struct_pop_node.html">PopNode</a> objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly-allocated <a class="el" href="struct_node_store.html" title="This structure allows you to allocate PopNode objects in an array and then dole them out one at a tim...">NodeStore</a>. </dd></dl>

<p>Referenced by <a class="el" href="parse_8c.html#af0c365f8ca3def04d05c614325464e4a">countSegments()</a>, <a class="el" href="gptree_8c.html#ae5af677600280c92025347233baa38af">GPTree_new()</a>, and <a class="el" href="popnode_8c.html#adf4984b4dddc29e3125dbcb5614e41e1">SampNdx_shiftPtrs()</a>.</p>

</div>
</div>
<a class="anchor" id="aa1cebd64c243809bffc0cd835752d96f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PopNode_gaussian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pop_node.html">PopNode</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bounds.html">Bounds</a>&#160;</td>
          <td class="paramname"><em>bnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_par_store.html">ParStore</a> *&#160;</td>
          <td class="paramname"><em>ps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the value of each Gaussian parameter by sampling from the relevant distribution. </p>

<p>References <a class="el" href="popnode_8c.html#a632b830ab1cc9d151f9dbc0ea548b7b8">PopNode_gaussian_r()</a>, and <a class="el" href="popnode_8c.html#a39cc1d72eeefaa448f5624e91b6ccaef">PopNode_untouch()</a>.</p>

<p>Referenced by <a class="el" href="gptree_8c.html#a050fc67d9685821966f63d637fd0d021">GPTree_simulate()</a>.</p>

</div>
</div>
<a class="anchor" id="a632b830ab1cc9d151f9dbc0ea548b7b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PopNode_gaussian_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pop_node.html">PopNode</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bounds.html">Bounds</a>&#160;</td>
          <td class="paramname"><em>bnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_par_store.html">ParStore</a> *&#160;</td>
          <td class="paramname"><em>ps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse the population tree to reset the value of each Gaussian parameter by sampling from the relevant distribution. </p>
<p>Call PopNode_untouch before calling this function. </p>

<p>References <a class="el" href="parstore_8c.html#a0053f67db7aa70ec9ea8375183e0489a">ParStore_sample()</a>.</p>

<p>Referenced by <a class="el" href="popnode_8c.html#aa1cebd64c243809bffc0cd835752d96f">PopNode_gaussian()</a>.</p>

</div>
</div>
<a class="anchor" id="ae6bd97ddbb6bbf3f7dd6fe095c05e783"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PopNode_mix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pop_node.html">PopNode</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>mPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mixFree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pop_node.html">PopNode</a> *&#160;</td>
          <td class="paramname"><em>introgressor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pop_node.html">PopNode</a> *&#160;</td>
          <td class="paramname"><em>native</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect a child <a class="el" href="struct_pop_node.html">PopNode</a> to two parents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">child</td><td>pointer to the child <a class="el" href="struct_pop_node.html">PopNode</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mPtr</td><td>pointer to the gene flow variable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mixFree</td><td>1 if mPtr is a free parameter; 0 otherwise </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">introgressor</td><td>pointer to the introgressing parent </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">native</td><td>pointer to the native parent </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="misc_8c.html#a1f2415ec1f22a3a73f7702c0143d9402">eprintf()</a>, and <a class="el" href="popnode_8c.html#ab04a12a01209a7133ca0dd64275bc7f1">PopNode_sanityCheck()</a>.</p>

<p>Referenced by <a class="el" href="parse_8c.html#a3e66ac8c87432cfb59bb9f9881668892">parseMix()</a>.</p>

</div>
</div>
<a class="anchor" id="a83e0578531c5bec8f70842afca455eeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PopNode_randomize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pop_node.html">PopNode</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bounds.html">Bounds</a>&#160;</td>
          <td class="paramname"><em>bnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomly perturb all free parameters in tree while maintaining inequality constraints. </p>

<p>References <a class="el" href="popnode_8c.html#abba39acf5a9ab18b0e43397fcc4a963f">PopNode_randomize_r()</a>, and <a class="el" href="popnode_8c.html#a39cc1d72eeefaa448f5624e91b6ccaef">PopNode_untouch()</a>.</p>

<p>Referenced by <a class="el" href="gptree_8c.html#a4e31b205f2bed373438aa1cba23cf148">GPTree_randomize()</a>, and <a class="el" href="popnode_8c.html#adf4984b4dddc29e3125dbcb5614e41e1">SampNdx_shiftPtrs()</a>.</p>

</div>
</div>
<a class="anchor" id="abba39acf5a9ab18b0e43397fcc4a963f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PopNode_randomize_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pop_node.html">PopNode</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bounds.html">Bounds</a>&#160;</td>
          <td class="paramname"><em>bnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recurse through the tree perturbing free parameters. </p>
<p>Must call PopNode_untouch before calling this function. </p>

<p>References <a class="el" href="misc_8c.html#a2dfe91aee70b669f89ecec619eef1aa8">reflect()</a>.</p>

<p>Referenced by <a class="el" href="popnode_8c.html#a83e0578531c5bec8f70842afca455eeb">PopNode_randomize()</a>.</p>

</div>
</div>
<a class="anchor" id="a787a8e3df9a737056d227de9535647fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PopNode_shiftParamPtrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pop_node.html">PopNode</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add dp to each parameter pointer, using ordinary (not pointer) arithmetic. </p>

<p>Referenced by <a class="el" href="gptree_8c.html#a2b9d203ac68779115e4f3328fd7da161">GPTree_dup()</a>, and <a class="el" href="popnode_8c.html#adf4984b4dddc29e3125dbcb5614e41e1">SampNdx_shiftPtrs()</a>.</p>

</div>
</div>
<a class="anchor" id="a52bb7c23ac6fd4fa34283ac6918a4b21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PopNode_shiftPopNodePtrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pop_node.html">PopNode</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add dp to each <a class="el" href="struct_pop_node.html">PopNode</a> pointer, using ordinary (not pointer) arithmetic. </p>

<p>Referenced by <a class="el" href="gptree_8c.html#a2b9d203ac68779115e4f3328fd7da161">GPTree_dup()</a>, and <a class="el" href="popnode_8c.html#adf4984b4dddc29e3125dbcb5614e41e1">SampNdx_shiftPtrs()</a>.</p>

</div>
</div>
<a class="anchor" id="a39cc1d72eeefaa448f5624e91b6ccaef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PopNode_untouch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pop_node.html">PopNode</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all "touched" values to "false". </p>
<p>This algorithm is inefficient because it may process a single node multiple times. This happens when their is gene flow into the node, because then there multiple paths from the root to the node. It would be better to implement this as a shallow function (not recursive) and traverse the hash tab to execute it on each node exactly once. </p>

<p>Referenced by <a class="el" href="popnode_8c.html#aa1cebd64c243809bffc0cd835752d96f">PopNode_gaussian()</a>, and <a class="el" href="popnode_8c.html#a83e0578531c5bec8f70842afca455eeb">PopNode_randomize()</a>.</p>

</div>
</div>
<a class="anchor" id="ae747836810afb30f2a615c9a4c692b77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SampNdx_addSamples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_samp_ndx.html">SampNdx</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nsamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pop_node.html">PopNode</a> *&#160;</td>
          <td class="paramname"><em>pnode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add samples for a single population. </p>
<p>Should be called once for each sampled population. </p>

<p>References <a class="el" href="misc_8c.html#a1f2415ec1f22a3a73f7702c0143d9402">eprintf()</a>.</p>

<p>Referenced by <a class="el" href="parse_8c.html#afb861c0053c16210bdb3434df5a18e1a">parseSegment()</a>, and <a class="el" href="popnode_8c.html#adf4984b4dddc29e3125dbcb5614e41e1">SampNdx_shiftPtrs()</a>.</p>

</div>
</div>
<a class="anchor" id="aef67024f7444caedcd299ffec5037932"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SampNdx_equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_samp_ndx.html">SampNdx</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_samp_ndx.html">SampNdx</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This equality check doesn't do much, because the pointers in different <a class="el" href="struct_samp_ndx.html">SampNdx</a> objects don't have to be (in fact shouldn't be) equal. </p>

<p>Referenced by <a class="el" href="gptree_8c.html#a688976234f7a89a9730a7d594a536451">GPTree_equals()</a>, and <a class="el" href="popnode_8c.html#adf4984b4dddc29e3125dbcb5614e41e1">SampNdx_shiftPtrs()</a>.</p>

</div>
</div>
<a class="anchor" id="adc307f239dcf3390dca6b966c0d9b84e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SampNdx_populateTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_samp_ndx.html">SampNdx</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put samples into the gene tree. </p>
<p>Should be done at the start of each simulation. </p>

<p>References <a class="el" href="popnode_8c.html#a0a6a75adb1a581695e227e790d9da6ae">PopNode_newGene()</a>.</p>

<p>Referenced by <a class="el" href="gptree_8c.html#a050fc67d9685821966f63d637fd0d021">GPTree_simulate()</a>, and <a class="el" href="popnode_8c.html#adf4984b4dddc29e3125dbcb5614e41e1">SampNdx_shiftPtrs()</a>.</p>

</div>
</div>
<a class="anchor" id="a17e660609a395a135a64ef7ba2c48f05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SampNdx_ptrsLegal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_samp_ndx.html">SampNdx</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pop_node.html">PopNode</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pop_node.html">PopNode</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return 1 if all pointers in <a class="el" href="struct_samp_ndx.html">SampNdx</a> are in [start,end); return 0 otherwise. </p>

<p>Referenced by <a class="el" href="gptree_8c.html#a2b9d203ac68779115e4f3328fd7da161">GPTree_dup()</a>, and <a class="el" href="popnode_8c.html#adf4984b4dddc29e3125dbcb5614e41e1">SampNdx_shiftPtrs()</a>.</p>

</div>
</div>
<a class="anchor" id="adf4984b4dddc29e3125dbcb5614e41e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SampNdx_shiftPtrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_samp_ndx.html">SampNdx</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dpop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift all pointers within <a class="el" href="struct_samp_ndx.html">SampNdx</a> by an offset of magnitude dpop. </p>
<p>If sign &gt; 0, the shift is positive; otherwise it is negative. </p>

<p>References <a class="el" href="gene_8c.html#a7636722aae8dea1b918d7a6e11846c66">Gene_new()</a>, <a class="el" href="popnode_8c.html#a2f44cc2e60e06964d0fa7f43545b7ade">NodeStore_alloc()</a>, <a class="el" href="popnode_8c.html#a151f25e883d267b05e57811a7aee3e00">NodeStore_free()</a>, <a class="el" href="popnode_8c.html#a8955e500da0a712d161d84c3486727b0">NodeStore_new()</a>, <a class="el" href="popnode_8c.html#af039f9acdd8aee304d861eb7488e08ab">PopNode_addChild()</a>, <a class="el" href="popnode_8c.html#aa969e7747efda5dbeb88a33d648b54c1">PopNode_addSample()</a>, <a class="el" href="popnode_8c.html#a243771d5d518c1a0fcc0487e5f06df51">PopNode_new()</a>, <a class="el" href="popnode_8c.html#a74590003fe296cb82da9010d66520fa9">PopNode_nsamples()</a>, <a class="el" href="popnode_8c.html#af9683e39b487642b3b37eafa0513c61c">PopNode_printShallow()</a>, <a class="el" href="popnode_8c.html#a83e0578531c5bec8f70842afca455eeb">PopNode_randomize()</a>, <a class="el" href="popnode_8c.html#a787a8e3df9a737056d227de9535647fa">PopNode_shiftParamPtrs()</a>, <a class="el" href="popnode_8c.html#a52bb7c23ac6fd4fa34283ac6918a4b21">PopNode_shiftPopNodePtrs()</a>, <a class="el" href="popnode_8c.html#ae747836810afb30f2a615c9a4c692b77">SampNdx_addSamples()</a>, <a class="el" href="popnode_8c.html#aef67024f7444caedcd299ffec5037932">SampNdx_equals()</a>, <a class="el" href="popnode_8c.html#a092848a150eb15bac76bb65a0cbc30e2">SampNdx_init()</a>, <a class="el" href="popnode_8c.html#adc307f239dcf3390dca6b966c0d9b84e">SampNdx_populateTree()</a>, <a class="el" href="popnode_8c.html#a17e660609a395a135a64ef7ba2c48f05">SampNdx_ptrsLegal()</a>, <a class="el" href="popnode_8c.html#a7b0a85b6108243f1def413bf93d56521">SampNdx_sanityCheck()</a>, and <a class="el" href="misc_8c.html#a9f3d011e394b1f2aaa7d62f2700b082c">unitTstResult()</a>.</p>

<p>Referenced by <a class="el" href="gptree_8c.html#a2b9d203ac68779115e4f3328fd7da161">GPTree_dup()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 31 2016 17:48:09 for lego by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
