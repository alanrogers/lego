<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>lego: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">lego
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Lego is a system of programs written in C and Python, which uses counts of nucleotide site patterns to infer thehistoryofpopulationsize,subdivision,andgeneflow.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">lego Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Introduction</h1>
<p>Lego is a computer package that uses counts of nucleotide site patterns to estimate the history of population size, subdivision, and gene flow. It works by minimizing the difference between observed and expected counts of "nucleotide site patterns". Site patterns are summary statistics that are rich in information about sizes of and relationships among ancestral populations but are not influenced by the recent population size. So what is a site pattern?</p>
<p>Consider a sample consisting of one haploid genome drawn from each of 3 populations, <em>X</em>, <em>Y</em>, and <em>Z</em>. Suppose that, at a given nucleotide site, the derived allele is present in the genomes from <em>X</em> and <em>Y</em> but not that from <em>Z</em>. If so, then this nucleotide position will be said to exhibit the "*xy* site pattern." We ignore cases in which the derived allele is present in none of the samples, in only one of them, or in all of them. In other words, we consider only polymorphic, non-singleton site patterns. For the special case of the 3-population sample just described, there are only 3 such site patterns: <em>xy</em>, <em>xz</em>, and <em>yz</em>.</p>
<p>In the general case, with samples from <em>K</em> populations, the number of site patterns is <img class="formulaInl" alt="$2^K - K - 2$" src="form_0.png"/>. For example, there are 10 site patterns in a sample involving <img class="formulaInl" alt="$K=4$" src="form_1.png"/> populations. The table below shows data from a sample involving 4 populations, <em>X</em>, <em>Y</em>, <em>N</em>, and <em>D</em>. </p><pre class="fragment">SitePat          E[count]
     xy    340952.4592501
     xn     46874.1307236
     xd     46034.4670204
     yn     55137.4236715
     yd     43535.5248078
     nd    231953.3372578
    xyn     91646.1277991
    xyd     88476.9619569
    xnd     96676.3877423
    ynd    100311.4411513
</pre><p>The <code>E[count]</code> column shows numbers that can be thought of loosely as counts of site patterns in a genome-wide sample. The last line tells us that the <em>ynd</em> site pattern occurs at over 100,000 nucleotide sites.</p>
<p>These number cannot really be counts, because they aren't integers. This reflects the fact that our sample includes more than one haploid genome from each population, and a given SNP may contribute to several site patterns. The contribution to a given site pattern is the probability that a sub-sample, consisting of one haploid genome drawn at random from the larger sample of each population, would exhibit this site pattern. For example, suppose we have samples from three populations, <em>X</em>, <em>Y</em>, and <em>N</em>, and let <img class="formulaInl" alt="$p_{iX}$" src="form_2.png"/>, <img class="formulaInl" alt="$p_{iY}$" src="form_3.png"/>, and <img class="formulaInl" alt="$p_{iN}$" src="form_4.png"/> represent the frequencies of the derived allele at the <em>i*th SNP in these three samples. Then site pattern *xy</em> occurs at SNP <em>i</em> with probability <img class="formulaInl" alt="$z_i = p_{iX}p_{iY}(1-p_{iN})$" src="form_5.png"/> (Patterson et al 2010, Science, 328(5979):S129). Aggregating over SNPs, <img class="formulaInl" alt="$I_{xy} = \sum_i z_i$" src="form_6.png"/> summarizes the information in the data about this site pattern. These are the numbers that appear in the 2nd column of the table above.</p>
<p>The table above was generated by the program <a class="el" href="tabpat.html">tabpat</a>.</p>
<h1>Installation and testing</h1>
<p>The package is available at <a href="github.com/alanrogers/lego">github</a>. Before compiling, you must install two libraries: <code>pthreads</code> and <a href="http://www.gnu.org/software/gsl"><code>gsl</code></a>. You will need not only the libraries themselves but also several header files, such as <code>pthread.h</code>. I didn't need to install <code>pthreads</code>, because it came bundled with the Gnu C compiler. But the gsl was an extra. Under ubuntu Linux, you can install it like this: </p><pre class="fragment">sudo apt-get install libgsl0-dev
</pre><p>On the mac, using homebrew, the command is </p><pre class="fragment">brew install gsl
</pre><p>By default, the executable files will be copied into a directory named <code>bin</code> in your home directory. If you want them to go somewhere else, edit the first non-comment line of src/Makefile.</p>
<p>Then</p>
<ol type="1">
<li>Cd into the src directory.</li>
<li>Type "make".</li>
<li>Type "make install".</li>
</ol>
<p>This will try to place the executables into directory "bin" in the user's home directory. Make sure this directory appears in your PATH, so that the shell can find it.</p>
<p>To install in /usr/local/bin instead of $HOME/bin, type "sudo make
ginstall". You'll need administrative privileges.</p>
<p>This installation will work under unix-like operating systems, such as linux and Apple's osx. I haven't tried to port this software to Windows.</p>
<p>The directory <code>test</code> contains a unit test for many of the .c files in directory <code>src</code>. Within this directory, type</p>
<ol type="1">
<li>make xboot</li>
<li>./xboot</li>
</ol>
<p>to test the source file <code><a class="el" href="boot_8c.html" title="Functions for a moving blocks bootstrap. ">boot.c</a></code>. To run all unit tests, type "make". This will take awhile, as some of the unit tests are slow.</p>
<h1>Genetic input data</h1>
<p>Before doing data analysis with <code>lego</code>, you must generate data files in "daf" format. Such files end with ".daf", which stands for "derived
allele frequency. See the @ref daf "daf" command for instructions on
translating from "vcf" or "bcf" format into "daf".</p>
<p>The "daf" file is very simple and looks like this: </p><pre class="fragment">#chr        pos aa da                  daf
   1     752566  g  a 0.835294117647058854
   1     754192  a  g 0.858823529411764652
   1     755225  t  g 0.000000000000000000
   1     755228  t  g 0.000000000000000000
   1     765437  g  a 0.000000000000000000
</pre><p>The first line (beginning with "#") is an optional comment, which is used here to label the columns. The columns are as follows:</p>
<ol type="1">
<li>Character strings that label chromosomes or scaffolds.</li>
<li>Position of the SNP on the chromosome or scaffold, measured in base pairs. Daf format doesn't care whether nucleotide positions are numbered beginning with 0 or with 1, provided that they are consistent across files in a given analysis.</li>
<li>Ancestral allele, a single letter.</li>
<li>Derived allele, also a single letter. Loci with 3 or more alleles should be excluded.</li>
<li>Frequency of the derived allele within the sample.</li>
</ol>
<p>The lines should be sorted lexically by chromosome. Within chromosomes, they should be sorted in ascending numerical order of column 2.</p>
<h1><a class="anchor" id="lgo"></a>
Describing population history in an `lgo` file</h1>
<p>The ".lgo" format describes the history of population size, subdivision, and gene flow. It also identifies the position within the population network of each genetic sample. It is a plain-text file, which should be constructed with a text editor.</p>
<p>In the paragraphs below, I will introduce a small .lgo file a few lines at a time. The first line in my file is </p><pre class="fragment"># Example .lgo file
</pre><p>This is a comment. Comments extend from the sharp character to the end of the line. The next two lines define two convenience variables, whose names are "zero" and "one" </p><pre class="fragment">time fixed    zero=0
twoN fixed     one=1
</pre><p>The first is a "time" variable, which I will use for the tips of branches, where time equals 0. I declare it "fixed", which means that it will not change. The second is a "twoN" variable, which represents twice the size of a population. When there is only one sample per population, the sizes of recent populations do not matter, so I set them all equal to "one". Next, three more time variables named "Txyn", "Tn", and "Txy". </p><pre class="fragment">time free     Txyn=25920        # archaic-modern separation time
time fixed     Tn=1897          # time of Neanderthal admixture
time gaussian  Txy=3788 sd=1000 # Africa-Eurasia separation time
</pre><p>The comments hint at the meanings of these variables; the values are in generations. The first of these variables is "free", which means that <code>legofit</code> will estimate its value. The second is "fixed", a category we have already discussed. The last is "gaussian", a new category. Gaussian variables are used to represent exogeneous parameters whose values are known only approximately. They are modeled as Gaussian random variables. In this case, the mean is 3788 and the standard deviation is 1000. The two programs, <code>lego</code> and <code>legofit</code>, use Monte-Carlo integration to integrate across the uncertainty in Gaussian parameters.</p>
<p>Next, our file declares two variables that represent population sizes: </p><pre class="fragment">twoN free     2Nn=1000          # archaic population size
twoN free    2Nxy=10000         # early modern population size
</pre><p>These both happen to be free parameters, but we could also have declared them fixed or gaussian. Our measure of population size is twice the effective size of the population.</p>
<p>We have one more variable to declare: </p><pre class="fragment">mixFrac free  mN=0.02           # Neanderthal admixture into y
</pre><p>The "mixFrac" command declares a "mixture fraction"&ndash;the fraction of a some population that drives from introgression. As above, it could have been fixed or gaussian.</p>
<p>The next few lines of the input file declare the segments of the population network. The first of these is </p><pre class="fragment">segment x     t=zero   twoN=one    samples=1  # Africa
</pre><p>Here, "x" is the name of the segment, zero is the time at which it ends, and one is the population size. Note that "zero" and "one" are variables that we declared above. The "samples=1" phrase says that there is a genetic sample from the end of this segment. In other words, the date of the sample is "t=zero" in this example. If the segment has no samples, you can omit "samples=0". It is also possible to specify more than one sample, as in "samples=2". If you do this, the program will generate more complex site patterns, whose frequencies will depend on recent population size. In this situation, you would not want to set "twoN=one".</p>
<p>The next two lines are similar, and define two other terminal populations: </p><pre class="fragment">segment y     t=zero   twoN=one    samples=1  # Eurasia
segment n     t=Tn     twoN=2Nn    samples=1  # Neanderthal
</pre><p>Segment "n" does not end at time zero, but rather at the time, Tn, of Neanderthal admixture. It has one sample, whose date is also Tn. This is a bit of a stretch, because it assumes that the Neanderthal genome lived at the same time as the episode of admixture. I make this assumption for simplicity&ndash;this is only an example. There are 3 more segments to declare: </p><pre class="fragment">segment y2    t=Tn     twoN=one               # pre-mig eurasia
segment xy    t=Txy    twoN=2Nxy              # early modern
segment xyn   t=Txyn   twoN=2Nn               # ancestral
</pre><p>These segments don't have a "samples" component, because none of them have genetic samples. Segment y2 represents the Eurasian population before the episode of admixture. Note that it ends at the same time as segment n. This is necessary, because we will want to mix y2 and n below to model gene flow. Also note that the size of xyn equals 2Nn&ndash;the same variable we used in setting the size of segment n. This establishes a constraint: the sizes of xyn and n will always be equal, no matter how the optimizer adjusts the value of 2Nn.</p>
<p>The rest of the .lgo file defines relationships between segments. This involves two statements: "mix" and "derive". Consider the mix statement first: </p><pre class="fragment">mix    y  from y2 + mN * n      # y is a mixture of y2 and n
</pre><p>This says that y is a mixture of y2 and n, which must end at the same date. Specifically, a fraction mN of y comes from n and the remaining fraction comes from y2. Finally, we have 4 examples of the "derive" statement: </p><pre class="fragment">derive x  from xy               # x is child of xy
derive y2 from xy               # y2 is child of xy
derive xy from xyn              # xy is child of xyn
derive n  from xyn              # n is child of xyn
</pre><p>These statements establish ancestor-descendant relationships between segments. Note that x and y2 both derive from xy, so xy has two "children", but x and y2 each have only one parent. On the other hand, segment y has two parents, as defined in the "mix" statement above.</p>
<p>Segments cannot have more than two parents or more than two children. All segments should descend, eventually, from a single root.</p>
<p>Using this .lgo file as input, <code>lego -i 10000</code> produces </p><pre class="fragment">#########################################################
# lego: generate site patterns by coalescent simulation #
#########################################################

# Program was compiled: Dec 31 2016 10:15:33
# Program was run: Sat Dec 31 17:23:41 2016

# cmd: ./lego input.lgo -i 10000
# nreps                       : 10000
# input file                  : input.lgo
# not simulating mutations
# excluding singleton site patterns.
#       SitePat E[BranchLength]
            x:y   13860.8919110
            x:n      34.1363577
            y:n     505.0103002
</pre><p>The program reports the mean branch length in generations of three site patterns. For example, "x:y" refers to the pattern in which the derived allele is present in the samples x and y but not in n. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 31 2016 17:38:10 for lego by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
