/**
 * @file parmap.c
 * @brief Generic file, which is included by other files that map keys
 * to Param objects.
 * 
 * This class uses a left-leaning binary tree to build a map
 * that associates generic keys with structures that include
 * a pointer to the current value, the lower and upper bounds, and
 * the type of the parameter. The interface allows parameters to be
 * inserted and later looked up by key.
 *
 * Translated from Java code at
 * http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf 
 */
#include "param.h"
#include "strparmap.h"
#include "misc.h"
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>
#define RED 1
#define BLACK 0
#define ISRED(node) ((node)!=NULL && (node)->color==RED)

struct CLASS {
    Param *par; // locally owned
    int color;
    StrParMap *left, *right;
};

CLASS *METHOD(new)(Param *par);
CLASS *METHOD(insert_r)(StrParMap *h, Param *par);
CLASS *METHOD(rotateLeft)(StrParMap *h);
CLASS *METHOD(rotateRight)(StrParMap *h);
void   METHOD(flipColors)(StrParMap *h);

void METHOD(free)(CLASS *h) {
    if(h == NULL)
        return;
    METHOD(free)(h->left);
    METHOD(free)(h->right);
    Param_free(h->par);
    free(h);
}

CLASS *METHOD(new)(Param *par) {
    CLASS *self = malloc(sizeof(CLASS));
    if(self==NULL) {
        fprintf(stderr,"%s:%d: can't allocate memory\n",
                __FILE__, __LINE__);
        exit(1);
    }
    self->par = par;
    self->color = RED;
    return self;
}

Param *METHOD(search)(CLASS *root, KEYTYPE key) {
    StrParMap *x = root;
    while(x != NULL) {
        int diff = KEYCOMPARE(key, x->par->KEYNAME);
        if(diff == 0)
            return x->par;
        else if(diff < 0)
            x = x->left;
        else
            x = x->right;
    }
    return NULL;
}

CLASS *METHOD(insert)(CLASS *root, Param *par) {
    root = METHOD(insert_r)(root, par);
    root->color = BLACK;
    return root;
}

CLASS *METHOD(insert_r)(CLASS *h, Param *par) {
    if(h == NULL)
        return METHOD(new)(par);
    if(ISRED(h->left) && ISRED(h->right))
        METHOD(flipColors)(h);
    int diff = KEYCOMPARE(par->KEYNAME, h->par->KEYNAME);
    if(diff == 0) {
        fprintf(stderr,"%s:%d: duplicate key\n",
                __FILE__,__LINE__);
        exit(EXIT_FAILURE);
    }
    if( diff < 0 )
        h->left = METHOD(insert_r)(h->left, par);
    else {
        assert(diff > 0);
        h->right = METHOD(insert_r)(h->right, par);
    }
    if(ISRED(h->right) && !ISRED(h->left))
        h = METHOD(rotateLeft)(h);
    if(ISRED(h->left) && ISRED(h->left->left))
        h = METHOD(rotateRight)(h);
    return h;
}

CLASS *METHOD(rotateLeft)(CLASS *h) {
    CLASS *x = h->right;
    h->right = x->left;
    x->left = h;
    x->color = h->color;
    h->color = RED;
    return x;
}

CLASS *METHOD(rotateRight)(CLASS *h) {
    CLASS *x = h->left;
    h->left = x->right;
    x->right = h;
    x->color = h->color;
    h->color = RED;
    return x;
}

void METHOD(flipColors)(CLASS *h) {
    h->color = !h->color;
    h->left->color = !h->left->color;
    h->right->color = !h->right->color;
}

void METHOD(print)(CLASS *h, FILE *fp, int indent) {
    if(h == NULL)
        return;
    METHOD(print)(h->left, fp, indent+1);
    int i;
    for(i=0; i<indent; ++i)
        fprintf(fp,"%d", i);
    fprintf(fp, "[%s, %p, %s]\n",
            h->par->name,
            h->par->valptr,
            h->color==RED ? "red" : "black");
    METHOD(print)(h->right, fp, indent+1);
}
