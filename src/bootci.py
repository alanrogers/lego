#!/usr/bin/python
# Read output files generated by legofit, and calculate confidence
# interval of each parameter.
import sys
from math import floor, ceil
import datetime

# Print usage message and abort
def usage(msg1):
    if len(msg1) > 0:
        print >> sys.stderr, msg1
    msg = \
        """
usage: bootci.py [options] <central_tendency> <boot1> <boot2> ...

where <central_tendency> is the legofit output for the real data
and the <boot*> files are legofit output for bootstrap replicates.
Options may include:

  -c <x> or --conf <x>     Set confidence level.
  -h     or --help         Print this message.
  -l <x> or --label <x>    Set label.

The program writes to standard output.
"""
    print >> sys.stderr, msg
    exit(1)

# Parse legofit output file.  Return a tuple containing two lists:
# first a list of parameter names; second a list of parameter
# estimates.
def parselegofit(fname):
    ifile = open(fname, "r")
    parmap = {}
    estmap = {}

    for line in ifile:
        line = line.split("=")
        if len(line) != 2:
            continue

        key = line[0].strip()
        key = key.replace("2","two")
        if "Gaussian" in line[1]:
            value = 1.0
        else:
            value = float(line[1].strip())

        if key in parmap:
            estmap[key] = value
        else:
            parmap[key] = value

    ifile.close()

    parnames = sorted(estmap.keys())
    estimates = len(parnames)*[0.0]
    for i in range(len(parnames)):
        estimates[i] = estmap[parnames[i]]
    return (parnames, estimates)

# Interpolate in order to approximate the value v[p*(len-1)].  Raise
# exception if len(v)==0.
def interpolate(p, v):
    if len(v) == 0:
        raise Exception("interpolate can't deal with 0-length vector")

    goal = p*(len(v) - 1)
    i = int(floor(goal))
    j = int(ceil(goal))
    if i == j:
        return v[i]
    w = goal - i
    return (1.0-w)*v[i] + w*v[j]

conf = 0.95
realdata = None
bootnames = []
lbl = None

# Loop over command line arguments, ignoring the 0th.
# (The 0th is just the name of the program.)
i = 1
while(True):
    if i >= len(sys.argv):
        break
    elif sys.argv[i]=="-h" or sys.argv[i]=="--help":
        usage("")
    elif sys.argv[i]=="-c" or sys.argv[i]=="--confidence":
        i += 1
        if i >= len(sys.argv):
            usage("Missing arg to -c or --confidence")
        conf = float(sys.argv[i])
    elif sys.argv[i]=="-l" or sys.argv[i]=="--label":
        i += 1
        if i >= len(sys.argv):
            usage("Missing arg to -l or --label")
        lbl = sys.argv[i]
    elif sys.argv[i][0] == "-":
        usage("Unknown argument: %s" % sys.argv[i])
    else:
        if realdata == None:
            realdata = sys.argv[i]
        else:
            bootnames.append(sys.argv[i])
    i += 1

if len(bootnames) < 2:
    usage("Command line must list at least 3 input files")

print "# bootci.py run at: %s" % datetime.datetime.now()
print "# real data:", realdata
print "# bootstrap replicates:",
for i in range(len(bootnames)):
    print bootnames[i],
print
print "# %s: %0.3f" % ("confidence", conf)

parnames, realEst = parselegofit(realdata)
mat = []
mat.append(realEst)

for name in bootnames:
    parnames2, estimates = parselegofit(name)

    if parnames != parnames2:
        print >> sys.stderr, "Input files estimate different parameters"
        print >> sys.stderr, "  1:", parnames
        print >> sys.stderr, "  2:", parnames2
        exit(1)

    mat.append(estimates)

# transpose matrix, so that mat[i] is a list of estimates for a single
# parameter.
mat = zip(*mat)
assert len(mat) == len(parnames)

# number of parameters
npar = len(mat)

tailProb = (1.0 - conf)/2.0

if lbl:
    print "%10s %15s %15s %15s %s" % ("par", "est", "low", "high", "lbl")
else:
    print "%10s %15s %15s %15s" % ("par", "est", "low", "high")
for i in range(npar):
    v = sorted(mat[i])
    lowBnd = interpolate(tailProb, v)
    highBnd = interpolate(1.0-tailProb, v)
    if lbl:
        print "%10s %15.8f %15.8f %15.8f %s" % \
            (parnames[i], realEst[i], lowBnd, highBnd, lbl)
    else:
        print "%10s %15.8f %15.8f %15.8f" % \
            (parnames[i], realEst[i], lowBnd, highBnd)
