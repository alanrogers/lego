#!/usr/bin/python
# Read bootstrap output files generated by legofit, and calculate
# confidence interval of each parameter.
import sys
from math import floor, ceil

# Print usage message and abort
def usage(msg1):
    print >> sys.stderr, msg1
    msg = \
        """
usage: bootci.py [options] <bootfile1> <bootfile2> ...
where options may include:

  -c <x> or --conf <x>     Set confidence level.

The program writes to standard output.
"""
    print >> sys.stderr, msg
    exit(1)

# Parse legofit output file.  Return a tuple containing two lists:
# first a list of parameter names; second a list of parameter
# estimates.
def parselegofit(fname):
    ifile = open(fname, "r")
    parmap = {}
    estmap = {}

    for line in ifile:
        line = line.split("=")
        if len(line) != 2:
            continue

        key = line[0].strip()
        key = key.replace("2","two")
        value = float(line[1].strip())

        if key in parmap:
            estmap[key] = value
        else:
            parmap[key] = value

    ifile.close()

    parnames = sorted(estmap.keys())
    estimates = len(parnames)*[0.0]
    for i in range(len(parnames)):
        estimates[i] = estmap[parnames[i]]
    return (parnames, estimates)

# Interpolate in order to approximate the value v[p*(len-1)].  Raise
# exception if len(v)==0.
def interpolate(p, v):
    if len(v) == 0:
        raise Exception("interpolate can't deal with 0-length vector")
    
    goal = p*(len(v) - 1)
    i = int(floor(goal))
    j = int(ceil(goal))
    if i == j:
        return v[i]
    w = goal - i
    return (1.0-w)*v[i] + w*v[j]

conf = 0.95
fnames = []

# Loop over command line arguments, ignoring the 0th.
# (The 0th is just the name of the program.)
i = 1
while(True):
    if i >= len(sys.argv):
        break
    elif sys.argv[i]=="-c" or sys.argv[i]=="--confidence":
        i += 1
        if i >= len(sys.argv):
            usage("Missing arg to -c or --confidence")
        conf = float(sys.argv[i])
    elif sys.argv[i][0] == "-":
        usage("Unknown argument: %s" % sys.argv[i])
    else:
        fnames.append(sys.argv[i])
    i += 1

if len(fnames) < 2:
    usage("Command line must list at least 2 input files")

print "# inputs:",
for i in range(len(fnames)):
    print fnames[i],
print
print "# %s: %0.3f" % ("confidence", conf)

parnames = None
mat = []

for name in fnames:
    parnames2, estimates = parselegofit(name)

    if parnames:
        if parnames != parnames2:
            print >> sys.stderr, "Input files estimate different parameters"
            print >> sys.stderr, "  1:", parnames
            print >> sys.stderr, "  2:", parnames2
            exit(1)
    else:
        parnames = parnames2

    mat.append(estimates)

# transpose matrix, so that mat[i] is a list of estimates for a single
# parameter.    
mat = zip(*mat)
assert len(mat) == len(parnames)

# number of parameters
npar = len(mat)

tailProb = (1.0 - conf)/2.0

print "%10s %15s %15s" % ("Parameter", "lowBnd", "highBnd")
for i in range(npar):
    v = sorted(mat[i])
    lowBnd = interpolate(tailProb, v)
    highBnd = interpolate(1.0-tailProb, v)
    print "%10s %15.8f %15.8f" % (parnames[i], lowBnd, highBnd)


    
    
