/**
@file resid.c
@page resid
@author Alan R. Rogers
@brief Calculate residuals

# `resid`: calculate residuals

This program reads a list of data files (containing site pattern
frequencies) and another list of .legofit files (containing estimates
as generated by `legofit`). The .legofit files should be listed in the
same order as the data files, so that the i'th .legofit file describes
the output generated from the i'th data file. The `resid` program uses
this input to calculate residuals--the difference between observed and
fitted site pattern frequencies--for each data set.

Optionally, the user can specify one or more remappings, each of which
tells `resid` to collapse several populations into a single population.

@copyright Copyright (c) 2019, Alan R. Rogers
<rogers@anthro.utah.edu>. This file is released under the Internet
Systems Consortium License, which can be found in file "LICENSE".
*/

#include "strdblqueue.h"
#include "misc.h"
#include "branchtab.h"
#include <strings.h>
#include <time.h>

struct Mapping {
    char *lhs, *rhs;
};

typedef struct Mapping Mapping;

// Function prototypes
void usage(void);
int Mapping_size(Mapping *self);
Mapping *Mapping_new(const char *lhs, const char *rhs);
void Mapping_free(Mapping *self);
void Mapping_push(Mapping *self, const char *str);
const char *Mapping_lhs(Mapping *self);
const char *Mapping_rhs(Mapping *self);
void Mapping_print(Mapping *self, FILE *fp);

Mapping *Mapping_new(const char *lhs, const char *rhs) {
    Mapping *self = malloc(sizeof(Mapping));
    CHECKMEM(self);
    self->lhs = strdup(lhs);
    CHECKMEM(self->lhs);
    self->rhs = strdup(rhs);
    CHECKMEM(self->rhs);
    return self;
}

void Mapping_free(Mapping *self) {
    free(self->rhs);
    free(self->lhs);
    free(self);
}

int Mapping_size(Mapping *self) {
    return 1 + strchrcnt(self->rhs, ':');
}

// Get label of left-hand side
const char *Mapping_lhs(Mapping *self) {
    return self->lhs;
}

// Get label describing populations to be collapsed
const char *Mapping_rhs(Mapping *self) {
    return self->rhs;
}


void Mapping_print(Mapping *self, FILE *fp) {
    fprintf(fp, "# %s = %s\n", self->lhs, self->rhs);
}

//vars
const char *usageMsg =
    "usage: resid [options] <realdat> <bdat1> <bdat2> ... -L <real.legofit>\n"
    " <b1.legofit> <b2.legofit> ... [-M c=a+b ...]\n" "\n"
    " where realdat is the real data, each \"bdat\" file is the data\n"
    " for one bootstrap or simulation replicate, and each \"b#.legofit\"\n"
    " file is the legofit output from the corresponding bootstrap replicate\n"
    " Must include at least one data file and one .legofit file.\n" "\n"
    "Options:\n"
    "   -h or --help   : print this message\n"
    "   -M c=a+b       : map populations a and b into a single symbol, c\n";

void usage(void) {
    fputs(usageMsg, stderr);
    exit(EXIT_FAILURE);
}

int main(int argc, char **argv) {

    time_t currtime = time(NULL);

    hdr("resid: calculate residuals");
#if defined(__DATE__) && defined(__TIME__)
    printf("# Program was compiled: %s %s\n", __DATE__, __TIME__);
#endif
    printf("# Program was run: %s", ctime(&currtime));
    fflush(stdout);
    
    enum input_state { DATA, LEGO, REMAP };

    enum input_state state = DATA;
    int status = 0;
    int i, j;
    int nfiles=0, nLegoFiles=0, nmapping=0;

    for(i = 1; i < argc; i++) {
        if(argv[i][0] == '-') {
            if(strcmp(argv[i], "-L") == 0) {
                state = LEGO;
                continue;
            }else if(strcmp(argv[i], "-M") == 0) {
                state = REMAP;
                continue;
            }else if(strcmp(argv[i], "-h") == 0 ||
                     strcmp(argv[i], "--help") == 0) {
                usage();
            }else{
                fprintf(stderr,"unknown flag argument: %s\n", argv[i]);
                usage();
            }
        }
        switch(state) {
        case DATA:
            ++nfiles;
            break;
        case LEGO:
            ++nLegoFiles;
            break;
        case REMAP:
            ++nmapping;
            break;
        default:
            fprintf(stderr,"%s:%d: unknown state\n",__FILE__,__LINE__);
            exit(EXIT_FAILURE);
        }
    }
    if(nfiles != nLegoFiles) {
        fprintf(stderr, "%s:%d\n"
                " Inconsistent number of files!"
                " %d data files and %d legofit files\n",
                __FILE__, __LINE__, nfiles, nLegoFiles);
        usage();
    }

    if(nfiles < 1) {
        fprintf(stderr,"nfiles=%d; need at least 1\n", nfiles);
        usage();
    }

    fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);

    const char *datafname[nfiles], *legofname[nfiles];
    Mapping *mapping[nmapping];
    memset(mapping, 0, nmapping * sizeof(*mapping));
    state = DATA;
    int idata, ilego, imapping;
    idata=ilego=imapping=0;
    for(i = 1; i < argc; i++) {
        if(argv[i][0] == '-') {
            if(strcmp(argv[i], "-L") == 0) {
                state = LEGO;
                continue;
            }else if(strcmp(argv[i], "-M") == 0) {
                state = REMAP;
                continue;
            }else if(strcmp(argv[i], "-h") == 0 ||
                     strcmp(argv[i], "--help") == 0) {
                usage();
            }else{
                fprintf(stderr,"unknown flag argument: %s\n", argv[i]);
                usage();
            }
        }
        switch(state){
        case DATA:
            datafname[idata++] = argv[i];
            break;
        case LEGO:
            legofname[ilego++] = argv[i];
            break;
        case REMAP:
            {
                // parse string of form a=b:c:d
                char *next = argv[i];
                char *token = strsep(&next, "=");
                if(NULL==strchr(next, ':')) {
                    fprintf(stderr,"%s:%d remapping (%s) in wrong format.\n"
                            "Expecting 2 or more labels separated by ':'"
                            " characters.\n",
                            __FILE__,__LINE__,next);
                    exit(EXIT_FAILURE);
                }
                mapping[imapping] = Mapping_new(token, next);
                CHECKMEM(mapping[imapping]);
            }
            ++imapping;
            break;
        default:
            fprintf(stderr,"%s:%d: unknown state\n",__FILE__,__LINE__);
            exit(EXIT_FAILURE);
        }
    }
    putchar('\n');
    assert(idata==nfiles);
    assert(ilego==nfiles);
    assert(imapping==nmapping);

    fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);

    for(imapping=0; imapping < nmapping; ++imapping)
        Mapping_print(mapping[imapping], stdout);

    fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);
    // Read data and legofit files into an arrays of queues
    StrDblQueue *data_queue[nfiles], *lego_queue[nfiles];
    for(i = 0; i < nfiles; ++i) {
        lego_queue[i] = StrDblQueue_parseSitePat(legofname[i]);
        data_queue[i] = StrDblQueue_parseSitePat(datafname[i]);
        StrDblQueue_normalize(lego_queue[i]);
        StrDblQueue_normalize(data_queue[i]);
        if(i==0) {
            checkConsistency(datafname[0], legofname[0],
                             data_queue[0], lego_queue[0]);
            continue;
        }
        checkConsistency(legofname[0], legofname[i],
                         lego_queue[0], lego_queue[i]);
        checkConsistency(datafname[0], legofname[i],
                         data_queue[0], data_queue[i]);
    }

    fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);

    // Create LblNdx object with an entry for each population
    tipId_t tid;
    LblNdx lndx;
    LblNdx_init(&lndx);
    LblNdx lndx2 = lndx;
    tipId_t collapse[nmapping];
    collapse[0] = 0;
    StrDblQueue *sdq;
    for(sdq=data_queue[0]; sdq; sdq = sdq->next) {
        char *s = sdq->strdbl.str;
        while(1) {
            char *colon = strchr(s, ':');
            char buff[100];
            int len;
            if(colon == NULL) {
                tid = LblNdx_getTipId(&lndx, s);
                if(tid == 0)
                    LblNdx_addSamples(&lndx, 1u, s);
                break;
            }
            len = colon - s;
            status = strnncopy(sizeof(buff), buff, len, s);
            if(status) {
                fprintf(stderr,"%s:%d: buffer overflow\n",
                        __FILE__,__LINE__);
                exit(EXIT_FAILURE);
            }
            tid = LblNdx_getTipId(&lndx, s);
            if(tid == 0)
                LblNdx_addSamples(&lndx, 1u, buff);
            s = colon+1;
        }
    }

    fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);

    // number of site patterns
    int npat = 0;

    // Arrays to be allocated once we have the collapsed dimension.
    // resid[i*nfiles + j] is residual for pattern i in file j
    double *mat = NULL;
    tipId_t *pat = NULL;

    // Apply remappings in sequence to produce a vector of collapse
    // integers and a single LblNdx object, which describes the result
    // of all remappings.
    for(imapping=0; imapping < nmapping; ++imapping) {
        const char *rhs = Mapping_rhs(mapping[imapping]);
        collapse[imapping] = LblNdx_getTipId(&lndx2, rhs);
        LblNdx_collapse(&lndx2, collapse[imapping],
                        Mapping_lhs(mapping[imapping]));
    }

    fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);

    // Each pass through the loop calculates residuals for a pair
    // of files: a data file and a legofit file.
    for(i=0; i<nfiles; ++i) {
        StrDbl strdbl;

        fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);
        // Convert queues to BranchTab objects
        BranchTab *resid = BranchTab_new();
        while(data_queue[i] != NULL) {
            data_queue[i] = StrDblQueue_pop(data_queue[i], &strdbl);
            tid = LblNdx_getTipId(&lndx, strdbl.str);
            if(tid == 0) {
                fprintf(stderr,"%s:%d:unknown label (%s)\n",
                        __FILE__,__LINE__,strdbl.str);
                exit(EXIT_FAILURE);
            }
            BranchTab_add(resid, tid, strdbl.val);
        }
        fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);
        BranchTab *fitted = BranchTab_new();
        while(lego_queue[i] != NULL) {
            fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);
            lego_queue[i] = StrDblQueue_pop(lego_queue[i], &strdbl);
            fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);
            tid = LblNdx_getTipId(&lndx, strdbl.str);
            fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);
            if(tid == 0) {
                fprintf(stderr,"%s:%d:unknown label (%s)\n",
                        __FILE__,__LINE__,strdbl.str);
                exit(EXIT_FAILURE);
            }
            fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);
            BranchTab_add(fitted, tid, strdbl.val);
            fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);
        }

        fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);
        // Collapse BranchTab objects by applying all remappings one
        // after the other.
        for(imapping=0; imapping < nmapping; ++imapping) {
            BranchTab *tmp;
            tmp = BranchTab_collapse(resid, collapse[imapping]);
            BranchTab_free(resid);
            resid = tmp;

            tmp = BranchTab_collapse(fitted, collapse[imapping]);
            BranchTab_free(fitted);
            fitted = tmp;
        }

        fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);
        // Set npat, pat. Allocate mat.
        if(npat==0) {
            double *frq = NULL, *sqr = NULL;
            npat = BranchTab_size(resid);
            mat = malloc(npat * nfiles * sizeof(*mat));
            pat = malloc(npat * sizeof(*pat));
            frq = malloc(npat * sizeof(*frq));
            sqr = malloc(npat * sizeof(*sqr));
            CHECKMEM(mat);
            CHECKMEM(pat);
            CHECKMEM(frq);
            CHECKMEM(sqr);
            memset(mat, 255u, npat*nfiles*sizeof(*mat));
            BranchTab_toArrays(resid, npat, pat, frq, sqr);
            qsort(pat, (size_t) npat, sizeof(pat[0]), compare_tipId);
            free(frq);
            free(sqr);
        }

        fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);
        // Normalize the BranchTabs
        if(BranchTab_normalize(resid))
            DIE("can't normalize empty BranchTab");
        if(BranchTab_normalize(fitted))
            DIE("can't normalize empty BranchTab");

        // calculate residuals for current pair of files
        BranchTab_minusEquals(resid, fitted);

        fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);
        // store residual in matrix
        for(j=0; j < npat; ++j)
            mat[j*nfiles + i] = BranchTab_get(resid, pat[j]);

        BranchTab_free(resid);
        BranchTab_free(fitted);
        fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);
    }
    fprintf(stderr,"%s:%d\n",__FILE__,__LINE__);

    // output: remove suffix from file names and truncate
    printf("%-10s", "SitePat");
    for(j=0; j < nfiles; ++j) {
        char *p = strrchr(legofname[j], '.');
        if(p)
            *p = '\0';
        printf(" %13.13s", legofname[j]);
    }
    putchar('\n');
    for(i=0; i<npat; ++i) {
        char lbl[100];
        patLbl(sizeof(lbl), lbl, pat[i], &lndx2);
        printf("%-10s", lbl);
        for(j=0; j < nfiles; ++j) 
            printf(" %13.10lf", mat[i*nfiles + j]);
        putchar('\n');
    }
    putchar('\n');

    free(mat);
    free(pat);
    
    return 0;
}
