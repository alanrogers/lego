/**
@file maub.c
@page maub
@author Alan R. Rogers and Daniel Tabin
@brief Bootstrap model averaging

# `maub`: model averaging using BEPE

Bootstrap model averaging was proposed by Buckland et al (Biometrics,
53(2):603-618). It can be used with weights provided by any method of
model selection, including @ref bepe "bepe" and @ref clic
"clic". Model selection is applied to the real data and also to a set
of bootstrap replicates. The weight, \f$w_i\f$ of the i'th model is
the fraction of these data sets for which the i'th model wins. In
other words, it is the fraction of data sets for which the i'th model
has the smallest information criterion.

The model-averaged estimator of a parameter, \f$\theta\f$, is the
average across models, weighted by \f$w_i\f$, of the model-specific
estimates of \f$\theta\f$. Models in which \f$\theta\f$ does not
appear are omitted from the weighted average.

To construct confidence intervals, we average across models within
each bootstrap replicate to obtain a bootstrap distribution of
model-averaged estimates.

Usage: maub <m1.msc> ... <mK.msc> -F <m1.flat> ... <mK.flat>

Here, the "mX" arguments refer to model "X". The "msc" suffix stands
for "model selection criterion". There are currently two options: @ref
bepe "bepe" and @ref clic "clic". Thus, the first command-line
argument might look like either "m1.bepe" or "m1.clic".

In either case, the "msc" files consist (apart from sharp-delimited
comments) of two columns. The first column gives the model selection
criterion, and the second column names the data file to which that
criterion refers. The first row should refer to the real data and the
remaining rows to bootstrap replicates. Model selection criteria are
defined so that low numbers indicate preferred models. I
will refer to these numbers as "badness" values.

After the `-F` argument comes a list of files, each of which can be
generated by @ref flatfile "flatfile.py". There must be a `.flat` file
for each model, so the number of `.flat` files should equal the number
of `.bepe` files. The first row of a `.flat` file is a header and
consists of column labels. Each column refers to a different
parameter, and the column labels are the names of these
parameters. The various `.flat` files need not agree about the number
of parameters or about the order of the parameters they share. But
shared parameters must have the same name in each `.flat` file.

After the header, each row in a `.flat` file refers to a different
data set. The first row after the header refers to the real data. Each
succeeding row refers to a bootstrap replicate. The number of rows
(excluding comments and the header) should agree with the numbers of
rows in the `.bepe` or `.clic` files.

In all types of input files, comments begin with a sharp character
and are ignored.

When `maub` runs, the first step is to calculate model weights,
\f$w_{i}\f$, where \f$i\f$ runs across models. The value of
\f$w_{i}\f$ is the fraction data sets (i.e. of rows in the `.bepe`
files) for which \f$i\f$ is the best model (i.e. the one with the
lowest badness value.

In the next step, `maub` averages across models to obtain a
model-averaged estimate of each parameter. This is done separately for
each data set: first for the real data and then for each bootstrap
replicate. Some parameters may be missing from some models. In this
case, the average runs only across models that include the parameter,
and the weights are re-normalized so that they sum to 1 within this
reduced set of models. If a parameter is present only in models with
weight zero, its model-averaged value is undefined and prints as "nan"
(not a number). 

Finally, the program uses the bootstrap distribution of model-averaged
parameter estimates to construct a 95% confidence interval for each
parameter. 

The program produces two output files. The first of these is written
to standard output and has the same form as the output of \ref
bootci "bootci.py". The first column consists of parameter names and the
2nd of model-averaged parameter estimates. The 3rd and 4th columns are
the lower and upper bounds of the confidence intervals.

The program also writes a file in the format of `ref flatfile
"flatfile.py". There is a header listing parameter labels. After the
header, row *i* gives the model-averaged estimate of each parameter
for the *i*th bootstrap replicate.

@copyright Copyright (c) 2018, Alan R. Rogers
<rogers@anthro.utah.edu>. This file is released under the Internet
Systems Consortium License, which can be found in file "LICENSE".
*/


/*
Structure to hold data of one flat file
*/

typedef struct Flat Flat;
struct Flat {
	int nparams;			//size of data
	int ndtsets;			//size of data

	double** values;		//data
	char** param_names;		//What parameters data represents
};

/*
Simple two way list that stores paramater values
*/

typedef struct Param_List Param_List;
struct Param_List {
	char* val;		//parameter

	Param_List* next;		//next
	Param_List* prev;		//prev
};


#include "misc.h"
#include <string.h>
#include <time.h>

void usage(void);
void Param_List_push(char* param, Param_List* node);
int Param_List_get_index(char* param, Flat f);
bool Param_List_has_param(Flat f, char* p);

double* maub_parse_bepe(const char* file_name);
int get_lines(const char* file_name);
Flat* Flat_new(const char** file_names, int nmodels, int ndtsets);
void Flat_free(Flat f);

const char *usageMsg =
    "Usage: maub <m1.msc> ... <mK.msc> -F <m1.flat> ... <mK.flat>\n"
    "\n"
    "Here, the \"mX\" arguments refer to model \"X\". The \"msc\" suffix\n"
    "stands for \"model selection criterion\". There are currently two\n"
    "options: \"bepe\" and \"clic\". Thus, the first command-line\n"
    "argument might look like either \"m1.bepe\" or \"m1.clic\".\n\n"
    "In either case, the \"msc\" files consist (apart from sharp-delimited\n"
    "comments) of two columns. The first column gives the model selection\n"
    "criterion, and the second column names the data file to which that\n"
    "criterion refers. The first row should refer to the real data and the\n"
    "remaining rows to bootstrap replicates. Model selection criteria are\n"
    "defined so that low numbers indicate preferred models.\n\n"
    "After the \"-F\" argument comes a list of files, each of which can be\n"
    "generated by \"flatfile.py\". There must be a \".flat\" file\n"
    "for each model, so the number of \".flat\" files should equal the\n"
    "number of \".bepe\" files. The first row of a \".flat\" file is a header\n"
    "and consists of column labels. Each column refers to a different\n"
    "parameter, and the column labels are the names of these parameters.\n"
    "The various \".flat\" files need not agree about the number of\n"
    "parameters or about the order of the parameters they share. But\n"
    "shared parameters must have the same name in each \".flat\" file.\n\n"
    "After the header, each row in a \".flat\" file refers to a different\n"
    "data set. The first row after the header refers to the real data. Each\n"
    "succeeding row refers to a bootstrap replicate. The number of rows\n"
    "(excluding comments and the header) should agree with the numbers of\n"
    "rows in the \".bepe\" files.\n\n"
    "In both types of input files, comments begin with a sharp character\n"
    "and are ignored.\n";

//Some global variables needed for some functions
Param_List* all_params;
int num_params = 0;
int warningremove;
void usage(void) {
	fputs(usageMsg, stderr);
	exit(EXIT_FAILURE);
}

/*
Adds a parameter to the paramater list
*/
void Param_List_push(char* param, Param_List* node){
	char* str = node->val;
	if(node->val =='\0'){		//if nothing in the list make the first node have filled
		node->val = param;
		num_params++;
		return;
	}
	if (strcmp(param, str) == 0){	//no copies allowed
		return;
	}
	else if (strcmp(param, str) < 0){		//If the new string should go before, put it before.
		Param_List* new_node = malloc(sizeof(Param_List));
		new_node->val = param;
		new_node->next = node;
		if(node->prev){
			new_node->prev = node->prev;
			node->prev->next = new_node;
		}
		else{								//If at the head reset the head
			new_node->prev = NULL;
			all_params = new_node;
		}
		node->prev = new_node;
		num_params++;
	}
	else if (strcmp(param, str) > 0){		//If you are at the end, keep going down the line
		if(node->next){
			Param_List_push(param, node->next);
		}
		else{
			Param_List* new_node = malloc(sizeof(Param_List));
			new_node->val = param;
			new_node->next = NULL;
			new_node->prev = node;
			node->next = new_node;
			num_params++;
		}
	}
}


/*
returns index of parameter in list
*/
int Param_List_get_index(char* param, Flat f){
	for (int i = 0; i < f.nparams; i++){
		if(strcmp(param, f.param_names[i]) == 0){
			return i;
		}
	}
	return -1;
}

/*
returns if  parameter is in list
*/
bool Param_List_has_param(Flat f, char* p){
	for (int i = 0; i < f.nparams; i++){
		if(strcmp(f.param_names[i], p) == 0){
			return true;
		}
	}
	return false;
}

/*
Returns the number of non commented lines in a file
*/
int get_lines(const char* file_name){
	FILE* f = fopen(file_name, "r");		//try and open file
	if(f==NULL) {
		fprintf(stderr,"%s:%d: can't read file \"%s\"\n",
			__FILE__,__LINE__,file_name);
		exit(EXIT_FAILURE);
	}

	char temp;
	int num_lines = 0;

	temp = fgetc(f);		//test if first line is commented
	if(temp != '#'){
		num_lines++;
	}

	do {					//loop through chars
		temp = fgetc(f);
		if(temp == '\n'){
 		CHECK: temp = fgetc(f);		//check for empty lines and #
			if(temp == '\n'){
				goto CHECK;
			}
			else if(temp == '#'){
				continue;
			}
			else{
				num_lines++;		//new lines without that = more lines
			}
		}

	} while (temp != EOF);		//end of file

	fclose(f);
	return (num_lines-1);
}

/*
Takes in data from a list of files
*/
Flat* Flat_new(const char** file_names, int nmodels, int ndtsets){
	Flat* flat_array = malloc(nmodels*sizeof(Flat));

	for (int i = 0; i < nmodels; i++){				//try to open files
		char ch;

		do {						//skip comments
			ch = fgetc(f);
			if(ch == '#'){
				while(ch != '\n'){
					ch = fgetc(f);
				}
				ch = '#';
			}
		} while (ch == '#');

		ungetc(ch,f);

		char temp_params[100][100];			//make an temp array of parameters
		int params = 0;

		do {
			warningremove = fscanf(f, "%s", temp_params[params]);		//scan in parameters
			ch = fgetc(f);
			ungetc(ch,f);
			params++;
		} while (ch != '\n');

		flat_array[i].nparams = params;				//set up for data
		flat_array[i].ndtsets = ndtsets;
		flat_array[i].param_names = malloc(params*sizeof(char*));
		flat_array[i].values = malloc(ndtsets*sizeof(double*));

		for (int j = 0; j < ndtsets; j++){
			flat_array[i].values[j] =  malloc(params*sizeof(double));
		}

		for (int j = 0; j < ndtsets; j++){				//scan indata
			for (int k = 0; k < params; k++){
				warningremove = fscanf(f, "%lf", &flat_array[i].values[j][k]);
			}
		}

		for (int j = 0; j < params; j++){					//move parameters to better location
			flat_array[i].param_names[j] = malloc(strlen(temp_params[j])*sizeof(char));
			strcpy(flat_array[i].param_names[j],temp_params[j]);
			Param_List_push (flat_array[i].param_names[j], all_params);
		}
	}
	return flat_array;
}

/*
Frees flats
*/
void Flat_free(Flat* f){
	for (int j = 0; j < f->ndtsets; j++){
		free(flat_array[i].values[j]);
	}

	for (int j = 0; j < f->nparams; j++){
		free(flat_array[i].param_names[j]);
	}
	free(flat_array[i].param_names);
	free(flat_array[i].values);

	free(f);
}

int main(int argc, char **argv){
	// Command line arguments specify file names
	if(argc < 4)
		usage();

	int nmodels = 0;
	int ndtsets = 0;

	//check to see if args make sense
	for(int i = 1; i < argc; i++){
		if (argv[i][0] == '-'){
			if(strcmp(argv[i], "-F") == 0){
				break;
			}
			else{
				usage();
			}
		}
		else{
			nmodels++;
		}
	}

	int nmodels_temp = 0;
	for(int i = (2+nmodels); i < argc; i++){
		if (argv[i][0] == '-'){
			usage();
		}
		else{
			nmodels_temp++;
		}
	}

	if(nmodels_temp != nmodels){
		fprintf(stderr, "%s:%d\n"
			" Inconsistent number of files!"
			" %d bepe files and %d flat files\n",
			__FILE__,__LINE__, nmodels, nmodels_temp);
		usage();
	}

	const char* bepe_file_names[nmodels];
	const char* flat_file_names[nmodels];

	FILE* bepe_files[nmodels];

	double winner_totals[nmodels];

	//read in files

	for(int i = 0; i < nmodels; ++i)
		bepe_file_names[i] = argv[i+1];
	for(int i = 0; i < nmodels; ++i)
		flat_file_names[i] = argv[i+2+nmodels];

	for(int i = 0; i < nmodels; ++i){
		winner_totals[i] = 0;
	}

	ndtsets = get_lines(bepe_file_names[0]);
	for(int i = 0; i < nmodels; ++i) {
		if((get_lines(flat_file_names[i])-1) != ndtsets) {
			fprintf(stderr, "%s:%d: inconsistent datasets in"
				" files %s (%u) and %s (%u)\n", __FILE__,__LINE__,
				flat_file_names[i], (get_lines(flat_file_names[i]) -1),
				bepe_file_names[0], ndtsets);
			exit(EXIT_FAILURE);
		}
		if(get_lines(bepe_file_names[i]) != ndtsets) {
			fprintf(stderr, "%s:%d: inconsistent datasets in"
				" files %s (%u) and %s (%u)\n", __FILE__,__LINE__,
				bepe_file_names[i], get_lines(bepe_file_names[i]),
				bepe_file_names[0], ndtsets);
			exit(EXIT_FAILURE);;
		}
	}

	//print basic setup

	#if defined(__DATE__) && defined(__TIME__)
   		printf("# Program was compiled: %s %s\n", __DATE__, __TIME__);
	#endif
    time_t currtime = time(NULL);
   	printf("# Program was run: %s", ctime(&currtime));
    printf("# cmd:");
    for(int i = 0; i < argc; ++i)
        printf(" %s", argv[i]);
    putchar('\n');
    fflush(stdout);

	int winner;
	double temp;
	double best_val;
	char buff[2000];

	//read in bepe files

	for(int i = 0; i < nmodels; ++i) { 
		bepe_files[i] = fopen(bepe_file_names[i], "r");
		if(bepe_files[i] == NULL) {
			fprintf(stderr,"%s:%d: can't read file \"%s\"\n",
		  		__FILE__,__LINE__, bepe_file_names[i]);
  			exit(EXIT_FAILURE); 
		}
		do {
			warningremove = fscanf(bepe_files[i], "%s", buff);
		} while(strcmp(buff, "DataFile"));
  	}
  	//go through each file and determine winner
	for(int j = 0; j < ndtsets; ++j) {
		best_val = 999999999;
		winner = -1;
		for(int i = 0; i < nmodels; ++i) {  
  			warningremove = fscanf(bepe_files[i], "%lf", &temp);

			if(temp < best_val){
				winner = i;
				best_val = temp;
  	  		}
			warningremove = fscanf(bepe_files[i], "%s", buff);
		}
  		winner_totals[winner]++;
	}

	//set up and read in flat files

	Flat* flat_input;

	all_params = malloc(sizeof(Param_List));
	all_params->val = '\0';
	all_params->prev = NULL;
	all_params->next = NULL;

	flat_input = Flat_new(flat_file_names, nmodels, ndtsets);

	Param_List* pl = all_params;
	Flat* finalflat = malloc(sizeof(Flat));
	finalflat->param_names = malloc(num_params*(sizeof(char*)));

	for (int i = 0; i < num_params; i++){
		finalflat->param_names[i] = malloc(strlen(pl->val)*sizeof(char));
		finalflat->param_names[i] = pl->val;
		pl = pl->next;
	}

	finalflat->ndtsets = ndtsets;
	finalflat->nparams = num_params;

	finalflat->values = malloc(num_params*sizeof(double*));
	double files_w_param;
	double final_val;
	double* weight = malloc(nmodels*sizeof(double));

	//Calculate maub

	for( int i = 0; i < num_params; i++){
		finalflat->values[i] = malloc(ndtsets*sizeof(double*));
		files_w_param = 0;
		char* par_i = finalflat->param_names[i];

		for( int j = 0; j < nmodels; j++){
			if(Param_List_has_param(flat_input[j], par_i)){
				files_w_param++;
			}
		}

		for( int j = 0; j < ndtsets; j++){
			final_val = 0;
			for( int k = 0; k < nmodels; k++){
				if(Param_List_has_param(flat_input[k], par_i)){
					weight[k] = ((winner_totals[k]/ndtsets));//*(nmodels/files_w_param));
					final_val += (weight[k]*flat_input[k].values[j][Param_List_get_index(par_i, flat_input[k])]);
				}
			}
			finalflat->values[i][j] = final_val;
		}
	}

	//print out data

	printf("#%15s %15s %15s %15s\n", "i", "Weight", "MSC_file", "Flat_file");
    for(int i=0; i<nmodels; ++i){
        printf("#%15u %15.10lg %15s %15s\n", i, weight[i], bepe_file_names[i], flat_file_names[i]);
    }
    putchar('\n');

	printf("# Model-averaged parameter estimates\n");
    for(int i = 0; i < num_params; i++){
        printf(" %s", finalflat->param_names[i]);
    }
    putchar('\n');
    for(int i=0; i < ndtsets; ++i) {
        for(int j=0; j < num_params; ++j){
        	if(finalflat->values[j][i] > 10e-100){
            	printf(" %0.10g", finalflat->values[j][i]);
        	}
        	else{
        		printf(" nan");
        	}
        }
        putchar('\n');
    }

	//free everything!
	while(all_params){
		Param_List* temp_pl = all_params->next;
		free(all_params);
		all_params = temp_pl;
	}
	Flat_free(finalflat);
	for (int i = 0; i < nmodels; i++){
		Flat_free(flat_input[i]);
	}
	free(flat_input);
}