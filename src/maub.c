/**
@file maub.c
@page maub
@author Alan R. Rogers and Daniel Tabin
@brief Bootstrap model averaging

# `maub`: model averaging using BEPE

Bootstrap model averaging was proposed by Buckland et al (Biometrics,
53(2):603-618). It can be used with weights provided by any method of
model selection. Model selection is applied to the real data and also
to a set of bootstrap replicates. The weight, \f$w_i\f$ of the i'th
model is the fraction of these data sets for which the i'th model
wins.

The model-averaged estimator of a parameter, \f$\theta\f$, is the
average across models, weighted by \f$w_i\f$, of the model-specific
estimates of \f$\theta\f$. Models in which \f$\theta\f$ does not
appear are omitted from the weighted average.

To construct confidence intervals, we average across models within
each bootstrap replicate to obtain a bootstrap distribution of
model-averaged estimates.

Usage: maub m1.bepe m2.bepe ... mK.bepe -F m1.flat m2.flat ... mK.flat

Here, the mX.bepe file refer to different models of population
history. Each of these files consists of a list of numbers, one on
each line. The first line refers to the real data, and each succeeding
line refers to a single bootstrap replicate. The numbers may be
generated by bepe or clic. They should be criteria for model
selection, defined so that low numbers indicate preferred models. I
will refer to these numbers as "badness" values.

After the `-F` argument comes a list of files, each of which can be
generated by @ref flatfile "flatfile.py". There must be f `.flat` file
for each model, so the number of `.flat` files should equal the number
of `.bepe` files. The first row of a `.flat` file is a header and
consists of column labels. Each column refers to a different
parameter, and the column labels are the names of these
parameters. The various `.flat` files need not agree about the number
of parameters or about the order of the parameters they share. But
shared parameters must have the same name in each `.flat` file.

After the header, each row in a `.flat` file refers to a different
data set. The first row after the header refers to the real data. Each
succeeding row refers to a bootstrap replicate. The number of rows
(excluding comments and the header) should agree with the numbers of
rows in the `.bepe` files.

In both types of input files, comments begin with a sharp character
and are ignored.

When `maub` runs, the first step is to calculate model weights,
\f$w_{i}\f$, where \f$i\f$ runs across models. The value of
\f$w_{ij}\f$ is the fraction data sets (i.e. of rows in the `.bepe`
files) for which \f$i\f$ is the best model (i.e. the one with the
lowest badness value.

In the next step, `maub` averages across models to obtain a
model-averaged estimate of each parameter. This is done separately for
each data set: first for the real data and then for each bootstrap
replicate. Some parameters may be missing from some models. In this
case, the average runs only across models that include the parameter,
and the weights are re-normalized so that they sum to 1 within this
reduced set of models.

Finally, the program uses the bootstrap distribution of model-averaged
parameter estimates to construct a 95% confidence interval for each
parameter. 

The program produces two output files. The first of these is written
to standard output and has the same form as the output of \ref
bootci "bootci.py". The first column consists of parameter names and the
2nd of model-averaged parameter estimates. The 3rd and 4th columns are
the lower and upper bounds of the confidence intervals.

The program also writes a file in the format of `ref flatfile
"flatfile.py". There is a header listing parameter labels. After the
header, row *i* gives the model-averaged estimate of each parameter
for the *i*th bootstrap replicate.

@copyright Copyright (c) 2018, Alan R. Rogers
<rogers@anthro.utah.edu>. This file is released under the Internet
Systems Consortium License, which can be found in file "LICENSE".
*/

typedef struct flat flat;
struct flat {
	int nparams;
	int ndatum;

	double** values;
	char** param_names;
};

typedef struct param_list param_list;
struct param_list {
	char* val;

	param_list* next;
	param_list* prev;
};


#include "misc.h"
#include <string.h>

void usage(void);
void push_param(char* param, param_list* node);
int get_index(char* param, flat f);

double* maub_parse_bepe(const char* file_name);
int get_lines(const char* file_name);
flat* get_flats(const char** file_names, int nfiles, int ndatum);

const char *usageMsg =
    "Usage: maub m1.bepe m2.bepe ... mK.bepe -F m1.flat m2.flat ... mK.flat\n"
    "\n"
	"Here, the mX.bepe file refer to different models of population\n"
	"history. Each of these files consists of a list of numbers, one on\n"
	"each line. The first line refers to the real data, and each succeeding\n"
	"line refers to a single bootstrap replicate. The numbers may be\n"
	"generated by bepe or clic. They should be criteria for model\n"
	"selection, defined so that low numbers indicate preferred models. I\n"
	"will refer to these numbers as \"badness\" values.\n"
	"\n"
	"After the `-F` argument comes a list of files, each of which can be\n"
	"generated by @ref flatfile \"flatfile.py\". There must be f `.flat` file\n"
	"for each model, so the number of `.flat` files should equal the number\n"
	"of `.bepe` files. The first row of a `.flat` file is a header and\n"
	"consists of column labels. Each column refers to a different\n"
	"parameter, and the column labels are the names of these\n"
	"parameters. The various `.flat` files need not agree about the number\n"
	"of parameters or about the order of the parameters they share. But\n"
	"shared parameters must have the same name in each `.flat` file.\n"
	"\n"
	"After the header, each row in a `.flat` file refers to a different\n"
	"data set. The first row after the header refers to the real data. Each\n"
	"succeeding row refers to a bootstrap replicate. The number of rows\n"
	"(excluding comments and the header) should agree with the numbers of\n"
	"rows in the `.bepe` files.\n";

param_list* all_params;
int num_params = 0;

void usage(void) {
	fputs(usageMsg, stderr);
	exit(EXIT_FAILURE);
}

void push_param(char* param, param_list* node){
	char* str = node->val;
	if(node->val =='\0'){
		node->val = param;
		num_params++;
		return;
	}
	if (strcmp(param, str) == 0){
		return;
	}
	else if (strcmp(param, str) < 0){
		param_list* new_node = malloc(sizeof(param_list));
		new_node->val = param;
		new_node->next = node;
		if(node->prev){
			new_node->prev = node->prev;
			node->prev->next = new_node;
		}
		else{
			new_node->prev = NULL;
			all_params = new_node;
		}
		node->prev = new_node;
		num_params++;
	}
	else if (strcmp(param, str) > 0){
		if(node->next){
			push_param(param, node->next);
		}
		else{
			param_list* new_node = malloc(sizeof(param_list));
			new_node->val = param;
			new_node->next = NULL;
			new_node->prev = node;
			node->next = new_node;
			num_params++;
		}
	}
}

int get_index(char* param, flat f){
	for (int i = 0; i < f.nparams; i++){
		if(strcmp(param, f.param_names[i]) == 0){
			return i;
		}
	}
	return -1;
}

int get_lines(const char* file_name){
	FILE* f = fopen(file_name, "r");
	if(f==NULL) {
		fprintf(stderr,"%s:%d: can't read file \"%s\"\n",
			__FILE__,__LINE__,file_name);
		exit(EXIT_FAILURE);
	}

	char temp;
	int num_lines = 0;

	temp = fgetc(f);
	if(temp != '#'){
		num_lines++;
	}

	do {
		temp = fgetc(f);
		if(temp == '\n'){
 		CHECK: temp = fgetc(f);
			if(temp == '\n'){
				goto CHECK;
			}
			else if(temp == '#'){
				continue;
			}
			else{
				num_lines++;
			}
		}

	} while (temp != EOF);

	fclose(f);
	return (num_lines-1);
}

flat* get_flats(const char** file_names, int nfiles, int ndatum){
	flat* flat_array = malloc(nfiles*sizeof(flat));

	for (int i = 0; i < nfiles; i++){
		FILE* f = fopen(file_names[i], "r");
		if(f==NULL) {
			fprintf(stderr,"%s:%d: can't read file \"%s\"\n",
				__FILE__,__LINE__,file_names[i]);
			exit(EXIT_FAILURE);
		}

		char ch;

		do {
			ch = fgetc(f);
			if(ch == '#'){
				while(ch != '\n'){
					ch = fgetc(f);
				}
				ch = '#';
			}
		} while (ch == '#');

		ungetc(ch,f);

		char temp_params[100][100];
		int params = 0;

		do {
			fscanf(f, "%s", temp_params[params]);
			ch = fgetc(f);
			ungetc(ch,f);
			params++;
		} while (ch != '\n');

		flat_array[i].nparams = params;
		flat_array[i].ndatum = ndatum;
		flat_array[i].param_names = malloc(params*sizeof(char*));
		flat_array[i].values = malloc(ndatum*sizeof(double*));

		for (int j = 0; j < ndatum; j++){
			flat_array[i].values[j] =  malloc(params*sizeof(double));
		}

		for (int j = 0; j < ndatum; j++){
			for (int k = 0; k < params; k++){
				fscanf(f, "%lf", &flat_array[i].values[j][k]);
			}
		}

		for (int j = 0; j < params; j++){
			flat_array[i].param_names[j] = malloc(strlen(temp_params[j])*sizeof(char));
			strcpy(flat_array[i].param_names[j],temp_params[j]);
			push_param (flat_array[i].param_names[j], all_params);
		}
	}
	return flat_array;
}

int main(int argc, char **argv){
	// Command line arguments specify file names
	if(argc < 4)
		usage();

	int nfiles = 0;
	int ndatum = 0;

	for(int i = 1; i < argc; i++){
		if (argv[i][0] == '-'){
			if(strcmp(argv[i], "-F") == 0){
				break;
			}
			else{
				usage();
			}
		}
		else{
			nfiles++;
		}
	}

	int nfiles_temp = 0;
	for(int i = (2+nfiles); i < argc; i++){
		if (argv[i][0] == '-'){
			usage();
		}
		else{
			nfiles_temp++;
		}
	}

	if(nfiles_temp != nfiles){
		fprintf(stderr, "%s:%d\n"
			" Inconsistent number of files!"
			" %d bepe files and %d flat files\n",
			__FILE__,__LINE__, nfiles, nfiles_temp);
		usage();
	}

	const char* bepe_file_names[nfiles];
	const char* flat_file_names[nfiles];

	FILE* bepe_files[nfiles];

	int winner_totals[nfiles];

	for(int i = 0; i < nfiles; ++i)
		bepe_file_names[i] = argv[i+1];
	for(int i = 0; i < nfiles; ++i)
		flat_file_names[i] = argv[i+2+nfiles];

	for(int i = 0; i < nfiles; ++i){
		winner_totals[i] = 0;
	}

	ndatum = get_lines(bepe_file_names[0]);
	for(int i = 0; i < nfiles; ++i) {
		if((get_lines(flat_file_names[i])-1) != ndatum) {
			fprintf(stderr, "%s:%d: inconsistent datasets in"
				" files %s (%u) and %s (%u)\n", __FILE__,__LINE__,
				flat_file_names[i], (get_lines(flat_file_names[i]) -1),
				bepe_file_names[0], ndatum);
			exit(EXIT_FAILURE);
		}
		if(get_lines(bepe_file_names[i]) != ndatum) {
			fprintf(stderr, "%s:%d: inconsistent datasets in"
				" files %s (%u) and %s (%u)\n", __FILE__,__LINE__,
				bepe_file_names[i], get_lines(bepe_file_names[i]),
				bepe_file_names[0], ndatum);
			exit(EXIT_FAILURE);;
		}
	}

	int winner;
	double temp;
	double best_val;
	char buff[2000];

	for(int i = 0; i < nfiles; ++i) { 
		bepe_files[i] = fopen(bepe_file_names[i], "r");
		if(bepe_files[i] == NULL) {
			fprintf(stderr,"%s:%d: can't read file \"%s\"\n",
		  		__FILE__,__LINE__, bepe_file_names[i]);
  			exit(EXIT_FAILURE); 
		}
		do {
			fscanf(bepe_files[i], "%s", buff);
		} while(strcmp(buff, "DataFile"));
  	}

	for(int j = 0; j < ndatum; ++j) {
		best_val = 999999999;
		winner = -1;
		for(int i = 0; i < nfiles; ++i) {  
  			fscanf(bepe_files[i], "%lf", &temp);

			if(temp < best_val){
				winner = i;
				best_val = temp;
  	  		}
			fscanf(bepe_files[i], "%s", buff);
		}
  		winner_totals[winner]++;
	}

	flat* flat_input;

	all_params = malloc(sizeof(param_list));
	all_params->val = '\0';
	all_params->prev = NULL;
	all_params->next = NULL;

	flat_input = get_flats(flat_file_names, nfiles, ndatum);

	param_list* pl = all_params;
	flat* finalflat = malloc(sizeof(flat));
	finalflat->param_names = malloc(num_params*(sizeof(char*)));

	for (int i = 0; i < num_params; i++){
		finalflat->param_names[i] = malloc(strlen(pl->val)*sizeof(char));
		finalflat->param_names[i] = pl->val;
		pl = pl->next;
	}

	finalflat->ndatum = ndatum;
	finalflat->nparams = num_params;

	finalflat->values = malloc(num_params*sizeof(double*));
	for( int i = 0; i < num_params; i++){
		finalflat->values = malloc(ndatum*sizeof(double));
	}

	//free everything!
}