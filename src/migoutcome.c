#include "migoutcome.h"
#include "misc.h"
#include "ptrqueue.h"
#include <stdio.h>
#include <stdlib.h>

// not thread safe
static unsigned migration_event = 0;

typedef struct Split Split;

struct MigOutcomeJoin {
    uint64_t isec;  // intersection
    uint64_t lrem;  // left remainder
    uint64_t rrem;  // right remainder
};

/**
 * struct Split describes how one MigOutcome object should be split.
 * Multiple Split objects can be linked into a list. The total number
 * of IdSet objects generated by such a list is 2^n, where n is the
 * length of the list. 
 */
struct Split {
    unsigned event;
    unsigned noutcomes;
    uint64_t bits_a, bits_b;
    double pr;
};

struct MigOutcomeJoin MigOutcome_join(MigOutcome *left, MigOutcome *right);
static int MigOutcome_cmp(MigOutcome *a, unsigned event);
static MigOutcome *MigOutcome_new(MigOutcome *next,
                                  unsigned event,
                                  unsigned noutcomes,  
                                  uint64_t bits,
                                  double pr);
static Split *Split_new(unsigned event, unsigned noutcomes,
                        uint64_t bits_a, uint64_t bits_b);
static void Split_free(Split *self);

static Split *Split_new(unsigned event, unsigned noutcomes,
                        double pr, uint64_t bits_a, uint64_t bits_b) {
    Split *self = malloc(sizeof(Split));
    CHECKMEM(self);
    self->event = event;
    self->noutcomes = noutcomes;
    self->bits_a = bits_a;
    self->bits_b = bits_b;
    self->pr = pr;
    return self;
}

static void Split_free(Split *self) {
    assert(self);
    free(self);
}

/// Increment external migration_event variable.
unsigned nextMigrationEvent(void) {
    unsigned event = migration_event;
    migration_event += 1;
    return event;
}

static int MigOutcome_cmp(MigOutcome *a, unsigned event) {
    if(a == NULL || a->event > event)
        return 1;
    if(a->event < event)
        return -1;
    return 0;
}

/// Function calls itself recursively to walk through the pair of
/// MigOutcome lists, "left" and "right". If left and right are
/// mutually exclusive, return 1. Otherwise return 0. If 0 is
/// returned, splits to left is returned in ll, and splits to right
/// are returned in rl.
int MigOutcome_getSplits(PtrQueue *ll, PtrQueue *rl,
                         MigOutcome *left, MigOutcome *right) {
    if(left==NULL && right==NULL)
        return 0;
    uint64_t isec, lrem, rrem; // intersection, left and right remainders
    if(left==NULL || left->event > right->event) {
        // Set noutcomes low-order bits in lrem.
        lrem = rrem = 0;
        lrem = ~lrem >> (64 - right->noutcomes);
        isec = right->bits;
        lrem ^= isec; // Unset bits that are on in right->bits
    }else if(right==NULL || right->event > left->event) {
        lrem = rrem = 0;
        rrem = ~rrem >> (64 - left->noutcomes);
        isec = left->bits;
        lrem ^= isec; // Unset bits that are on in left->bits
    }else{
        isec = left->bits & right->bits;
        lrem = left->bits ^ isec;
        rrem = right->bits ^ isec;
    }

    Split *s;
    if(isec == 0) {
        // left and right are mutually exclusive: free all
        // Split objects and return 1.
        for(s=PtrQueue_pop(ll); s; s=PtrQueue_pop(ll))
            Split_free(s);
        for(s=PtrQueue_pop(rl); s; s=PtrQueue_pop(rl))
            Split_free(s);
        return 1;
    }

    if(lrem) { // split left
        assert(right);
        s = Split_new(right->event, right->noutcomes, right->pr, isec, lrem);
        PtrQueue_push(ll, s);
    }
    if(rrem) { // split right
        assert(left);
        s = Split_new(left->event, left->noutcomes, left->pr, isec, lrem);
        PtrQueue_push(rl, s);
    }

    // Procede through left and right lists
    if(left==NULL)
        return MigOutcome_getSplits(ll, rl, NULL, right->next);

    if(right==NULL)
        return MigOutcome_getSplits(ll, rl, left->next, NULL);

    if(left->event > right->event)
        return MigOutcome_getSplits(ll, rl, left, right->next);

    if(left->event < right->event)
        return MigOutcome_getSplits(ll, rl, left->next, right);

    return MigOutcome_getSplits(ll, rl, left->next, right->next);
}

struct MigOutcomeJoin MigOutcome_join(MigOutcome *left, MigOutcome *right) {
    assert(left->event == right->event);

    // intersection
    uint64_t isec = left->bits & right->bits;

    // left remainder
    uint64_t lrem = left->bits ^ isec;

    // right remainder
    uint64_t rrem = right->bits ^ isec;

    struct MigOutcomeJoin rval = {
                                  .isec = isec,
                                  .lrem = lrem,
                                  .rrem = rrem
    };

    return rval;
}

MigOutcome *MigOutcome_insert(MigOutcome *head,
                              unsigned event,
                              unsigned noutcomes,  
                              uint64_t bits,
                              double pr) {
    int cmp = MigOutcome_cmp(head, event);
    if(cmp < 0) {
        head->next = MigOutcome_insert(head->next, event, noutcomes,
                                       bits, pr);
        return head;
    }else if(cmp > 0) {
        return MigOutcome_new(head, event, noutcomes, bits, pr);
    }else{
        fprintf(stderr,"%s:%s:%d: can't insert a new outcome for"
                " existing migration event %u\n",
                __FILE__,__func__,__LINE__, event);
        exit(EXIT_FAILURE);
    }

    return NULL; // NOTREACHED
}

static MigOutcome *MigOutcome_new(MigOutcome *next,
                                  unsigned event,
                                  unsigned noutcomes,  
                                  uint64_t bits,
                                  double pr) {
    MigOutcome *self = malloc(sizeof(MigOutcome));
    CHECKMEM(self);

    self->event = event;
    self->noutcomes = noutcomes;
    self->bits = bits;
    self->pr = pr;
    self->next = next;
    return self;
}

MigOutcome *MigOutcome_dup(MigOutcome *old) {
    if(old == NULL)
        return NULL;
    MigOutcome *new = memdup(old, sizeof(MigOutcome));
    CHECKMEM(new);
    new->next = MigOutcome_dup(old->next);
    return new;
}

void MigOutcome_free(MigOutcome *self) {
    if(self == NULL)
        return;
    MigOutcome_free(self->next);
    free(self);
}

void MigOutcome_print(MigOutcome *self, FILE *fp) {
    if(self==NULL) {
        putc('\n', fp);
        return;
    }
    fprintf(fp,"%u:%llx:%g ",self->event, self->bits, self->pr);
    MigOutcome_print(self->next, fp);
}

